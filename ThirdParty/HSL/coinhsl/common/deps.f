! F77 dependencies
* COPYRIGHT (c) 1977 AEA Technology
*######DATE 14 Jan 1993
C       Toolpack tool decs employed.
C       Reference MA30JD removed.
C       SAVE statements added.
C       ZERO, ONE and UMAX made PARAMETER.
C
C  EAT 21/6/93 EXTERNAL statement put in for block data on VAXs.
C   3/1/96. LENOFF made into an assumed-size array.
C
C  JKR 18/1/11 N*N replaced by HUGE(N) to avoid integer overflow.
C
      SUBROUTINE MA30AD(NN,ICN,A,LICN,LENR,LENRL,IDISP,IP,IQ,IRN,LIRN,
     +                  LENC,IFIRST,LASTR,NEXTR,LASTC,NEXTC,IPTR,IPC,U,
     +                  IFLAG)
C IF  THE USER REQUIRES A MORE CONVENIENT DATA INTERFACE THEN THE MA28
C     PACKAGE SHOULD BE USED.  THE MA28 SUBROUTINES CALL THE MA30
C     SUBROUTINES AFTER CHECKING THE USER'S INPUT DATA AND OPTIONALLY
C     USING MC23A/AD TO PERMUTE THE MATRIX TO BLOCK TRIANGULAR FORM.
C THIS PACKAGE OF SUBROUTINES (MA30A/AD, MA30B/BD, MA30C/CD AND
C     MA30D/DD) PERFORMS OPERATIONS PERTINENT TO THE SOLUTION OF A
C     GENERAL SPARSE N BY N SYSTEM OF LINEAR EQUATIONS (I.E. SOLVE
C     AX=B). STRUCTUALLY SINGULAR MATRICES ARE PERMITTED INCLUDING
C     THOSE WITH ROW OR COLUMNS CONSISTING ENTIRELY OF ZEROS (I.E.
C     INCLUDING RECTANGULAR MATRICES).  IT IS ASSUMED THAT THE
C     NON-ZEROS OF THE MATRIX A DO NOT DIFFER WIDELY IN SIZE.  IF
C     NECESSARY A PRIOR CALL OF THE SCALING SUBROUTINE MC19A/AD MAY BE
C     MADE.
C A DISCUSSION OF THE DESIGN OF THESE SUBROUTINES IS GIVEN BY DUFF AND
C     REID (ACM TRANS MATH SOFTWARE 5 PP 18-35,1979 (CSS 48)) WHILE
C     FULLER DETAILS OF THE IMPLEMENTATION ARE GIVEN IN DUFF (HARWELL
C     REPORT AERE-R 8730,1977).  THE ADDITIONAL PIVOTING OPTION IN
C     MA30A/AD AND THE USE OF DROP TOLERANCES (SEE COMMON BLOCK
C     MA30I/ID) WERE ADDED TO THE PACKAGE AFTER JOINT WORK WITH REID,
C     SCHAUMBURG, WASNIEWSKI AND ZLATEV (DUFF, REID, SCHAUMBURG,
C     WASNIEWSKI AND ZLATEV, HARWELL REPORT CSS 135, 1983).
C
C MA30A/AD PERFORMS THE LU DECOMPOSITION OF THE DIAGONAL BLOCKS OF THE
C     PERMUTATION PAQ OF A SPARSE MATRIX A, WHERE INPUT PERMUTATIONS
C     P1 AND Q1 ARE USED TO DEFINE THE DIAGONAL BLOCKS.  THERE MAY BE
C     NON-ZEROS IN THE OFF-DIAGONAL BLOCKS BUT THEY ARE UNAFFECTED BY
C     MA30A/AD. P AND P1 DIFFER ONLY WITHIN BLOCKS AS DO Q AND Q1. THE
C     PERMUTATIONS P1 AND Q1 MAY BE FOUND BY CALLING MC23A/AD OR THE
C     MATRIX MAY BE TREATED AS A SINGLE BLOCK BY USING P1=Q1=I. THE
C     MATRIX NON-ZEROS SHOULD BE HELD COMPACTLY BY ROWS, ALTHOUGH IT
C     SHOULD BE NOTED THAT THE USER CAN SUPPLY THE MATRIX BY COLUMNS
C     TO GET THE LU DECOMPOSITION OF A TRANSPOSE.
C
C THE PARAMETERS ARE...
C THIS DESCRIPTION SHOULD ALSO BE CONSULTED FOR FURTHER INFORMATION ON
C     MOST OF THE PARAMETERS OF MA30B/BD AND MA30C/CD.
C
C N  IS AN INTEGER VARIABLE WHICH MUST BE SET BY THE USER TO THE ORDER
C     OF THE MATRIX.  IT IS NOT ALTERED BY MA30A/AD.
C ICN IS AN INTEGER ARRAY OF LENGTH LICN. POSITIONS IDISP(2) TO
C     LICN MUST BE SET BY THE USER TO CONTAIN THE COLUMN INDICES OF
C     THE NON-ZEROS IN THE DIAGONAL BLOCKS OF P1*A*Q1. THOSE BELONGING
C     TO A SINGLE ROW MUST BE CONTIGUOUS BUT THE ORDERING OF COLUMN
C     INDICES WITH EACH ROW IS UNIMPORTANT. THE NON-ZEROS OF ROW I
C     PRECEDE THOSE OF ROW I+1,I=1,...,N-1 AND NO WASTED SPACE IS
C     ALLOWED BETWEEN THE ROWS.  ON OUTPUT THE COLUMN INDICES OF THE
C     LU DECOMPOSITION OF PAQ ARE HELD IN POSITIONS IDISP(1) TO
C     IDISP(2), THE ROWS ARE IN PIVOTAL ORDER, AND THE COLUMN INDICES
C     OF THE L PART OF EACH ROW ARE IN PIVOTAL ORDER AND PRECEDE THOSE
C     OF U. AGAIN THERE IS NO WASTED SPACE EITHER WITHIN A ROW OR
C     BETWEEN THE ROWS. ICN(1) TO ICN(IDISP(1)-1), ARE NEITHER
C     REQUIRED NOR ALTERED. IF MC23A/AD BEEN CALLED, THESE WILL HOLD
C     INFORMATION ABOUT THE OFF-DIAGONAL BLOCKS.
C A IS A REAL/DOUBLE PRECISION ARRAY OF LENGTH LICN WHOSE ENTRIES
C     IDISP(2) TO LICN MUST BE SET BY THE USER TO THE  VALUES OF THE
C     NON-ZERO ENTRIES OF THE MATRIX IN THE ORDER INDICATED BY  ICN.
C     ON OUTPUT A WILL HOLD THE LU FACTORS OF THE MATRIX WHERE AGAIN
C     THE POSITION IN THE MATRIX IS DETERMINED BY THE CORRESPONDING
C     VALUES IN ICN. A(1) TO A(IDISP(1)-1) ARE NEITHER REQUIRED NOR
C     ALTERED.
C LICN  IS AN INTEGER VARIABLE WHICH MUST BE SET BY THE USER TO THE
C     LENGTH OF ARRAYS ICN AND A. IT MUST BE BIG ENOUGH FOR A AND ICN
C     TO HOLD ALL THE NON-ZEROS OF L AND U AND LEAVE SOME "ELBOW
C     ROOM".  IT IS POSSIBLE TO CALCULATE A MINIMUM VALUE FOR LICN BY
C     A PRELIMINARY RUN OF MA30A/AD. THE ADEQUACY OF THE ELBOW ROOM
C     CAN BE JUDGED BY THE SIZE OF THE COMMON BLOCK VARIABLE ICNCP. IT
C     IS NOT ALTERED BY MA30A/AD.
C LENR  IS AN INTEGER ARRAY OF LENGTH N.  ON INPUT, LENR(I) SHOULD
C     EQUAL THE NUMBER OF NON-ZEROS IN ROW I, I=1,...,N OF THE
C     DIAGONAL BLOCKS OF P1*A*Q1. ON OUTPUT, LENR(I) WILL EQUAL THE
C     TOTAL NUMBER OF NON-ZEROS IN ROW I OF L AND ROW I OF U.
C LENRL  IS AN INTEGER ARRAY OF LENGTH N. ON OUTPUT FROM MA30A/AD,
C     LENRL(I) WILL HOLD THE NUMBER OF NON-ZEROS IN ROW I OF L.
C IDISP  IS AN INTEGER ARRAY OF LENGTH 2. THE USER SHOULD SET IDISP(1)
C     TO BE THE FIRST AVAILABLE POSITION IN A/ICN FOR THE LU
C     DECOMPOSITION WHILE IDISP(2) IS SET TO THE POSITION IN A/ICN OF
C     THE FIRST NON-ZERO IN THE DIAGONAL BLOCKS OF P1*A*Q1. ON OUTPUT,
C     IDISP(1) WILL BE UNALTERED WHILE IDISP(2) WILL BE SET TO THE
C     POSITION IN A/ICN OF THE LAST NON-ZERO OF THE LU DECOMPOSITION.
C IP  IS AN INTEGER ARRAY OF LENGTH N WHICH HOLDS A PERMUTATION OF
C     THE INTEGERS 1 TO N.  ON INPUT TO MA30A/AD, THE ABSOLUTE VALUE OF
C     IP(I) MUST BE SET TO THE ROW OF A WHICH IS ROW I OF P1*A*Q1. A
C     NEGATIVE VALUE FOR IP(I) INDICATES THAT ROW I IS AT THE END OF A
C     DIAGONAL BLOCK.  ON OUTPUT FROM MA30A/AD, IP(I) INDICATES THE ROW
C     OF A WHICH IS THE I TH ROW IN PAQ. IP(I) WILL STILL BE NEGATIVE
C     FOR THE LAST ROW OF EACH BLOCK (EXCEPT THE LAST).
C IQ IS AN INTEGER ARRAY OF LENGTH N WHICH AGAIN HOLDS A
C     PERMUTATION OF THE INTEGERS 1 TO N.  ON INPUT TO MA30A/AD, IQ(J)
C     MUST BE SET TO THE COLUMN OF A WHICH IS COLUMN J OF P1*A*Q1. ON
C     OUTPUT FROM MA30A/AD, THE ABSOLUTE VALUE OF IQ(J) INDICATES THE
C     COLUMN OF A WHICH IS THE J TH IN PAQ.  FOR ROWS, I SAY, IN WHICH
C     STRUCTURAL OR NUMERICAL SINGULARITY IS DETECTED IQ(I) IS
C     NEGATED.
C IRN  IS AN INTEGER ARRAY OF LENGTH LIRN USED AS WORKSPACE BY
C     MA30A/AD.
C LIRN  IS AN INTEGER VARIABLE. IT SHOULD BE GREATER THAN THE
C     LARGEST NUMBER OF NON-ZEROS IN A DIAGONAL BLOCK OF P1*A*Q1 BUT
C     NEED NOT BE AS LARGE AS LICN. IT IS THE LENGTH OF ARRAY IRN AND
C     SHOULD BE LARGE ENOUGH TO HOLD THE ACTIVE PART OF ANY BLOCK,
C     PLUS SOME "ELBOW ROOM", THE  A POSTERIORI  ADEQUACY OF WHICH CAN
C     BE ESTIMATED BY EXAMINING THE SIZE OF COMMON BLOCK VARIABLE
C     IRNCP.
C LENC,IFIRST,LASTR,NEXTR,LASTC,NEXTC ARE ALL INTEGER ARRAYS OF
C     LENGTH N WHICH ARE USED AS WORKSPACE BY MA30A/AD.  IF NSRCH IS
C     SET TO A VALUE LESS THAN OR EQUAL TO N, THEN ARRAYS LASTC AND
C     NEXTC ARE NOT REFERENCED BY MA30A/AD AND SO CAN BE DUMMIED IN
C     THE CALL TO MA30A/AD.
C IPTR,IPC ARE INTEGER ARRAYS OF LENGTH N WHICH ARE USED AS WORKSPACE
C     BY MA30A/AD.
C U  IS A REAL/DOUBLE PRECISION VARIABLE WHICH SHOULD BE SET BY THE
C     USER TO A VALUE BETWEEN 0. AND 1.0. IF LESS THAN ZERO IT IS
C     RESET TO ZERO AND IF ITS VALUE IS 1.0 OR GREATER IT IS RESET TO
C     0.9999 (0.999999999 IN D VERSION).  IT DETERMINES THE BALANCE
C     BETWEEN PIVOTING FOR SPARSITY AND FOR STABILITY, VALUES NEAR
C     ZERO EMPHASIZING SPARSITY AND VALUES NEAR ONE EMPHASIZING
C     STABILITY. WE RECOMMEND U=0.1 AS A POSIBLE FIRST TRIAL VALUE.
C     THE STABILITY CAN BE JUDGED BY A LATER CALL TO MC24A/AD OR BY
C     SETTING LBIG TO .TRUE.
C IFLAG  IS AN INTEGER VARIABLE. IT WILL HAVE A NON-NEGATIVE VALUE IF
C     MA30A/AD IS SUCCESSFUL. NEGATIVE VALUES INDICATE ERROR
C     CONDITIONS WHILE POSITIVE VALUES INDICATE THAT THE MATRIX HAS
C     BEEN SUCCESSFULLY DECOMPOSED BUT IS SINGULAR. FOR EACH NON-ZERO
C     VALUE, AN APPROPRIATE MESSAGE IS OUTPUT ON UNIT LP.  POSSIBLE
C     NON-ZERO VALUES FOR IFLAG ARE ...
C
C -1  THE MATRIX IS STRUCTUALLY SINGULAR WITH RANK GIVEN BY IRANK IN
C     COMMON BLOCK MA30F/FD.
C +1  IF, HOWEVER, THE USER WANTS THE LU DECOMPOSITION OF A
C     STRUCTURALLY SINGULAR MATRIX AND SETS THE COMMON BLOCK VARIABLE
C     ABORT1 TO .FALSE., THEN, IN THE EVENT OF SINGULARITY AND A
C     SUCCESSFUL DECOMPOSITION, IFLAG IS RETURNED WITH THE VALUE +1
C     AND NO MESSAGE IS OUTPUT.
C -2  THE MATRIX IS NUMERICALLY SINGULAR (IT MAY ALSO BE STRUCTUALLY
C     SINGULAR) WITH ESTIMATED RANK GIVEN BY IRANK IN COMMON BLOCK
C     MA30F/FD.
C +2  THE  USER CAN CHOOSE TO CONTINUE THE DECOMPOSITION EVEN WHEN A
C     ZERO PIVOT IS ENCOUNTERED BY SETTING COMMON BLOCK VARIABLE
C     ABORT2 TO .FALSE.  IF A SINGULARITY IS ENCOUNTERED, IFLAG WILL
C     THEN RETURN WITH A VALUE OF +2, AND NO MESSAGE IS OUTPUT IF THE
C     DECOMPOSITION HAS BEEN COMPLETED SUCCESSFULLY.
C -3  LIRN HAS NOT BEEN LARGE ENOUGH TO CONTINUE WITH THE
C     DECOMPOSITION.  IF THE STAGE WAS ZERO THEN COMMON BLOCK VARIABLE
C     MINIRN GIVES THE LENGTH SUFFICIENT TO START THE DECOMPOSITION ON
C     THIS BLOCK.  FOR A SUCCESSFUL DECOMPOSITION ON THIS BLOCK THE
C     USER SHOULD MAKE LIRN SLIGHTLY (SAY ABOUT N/2) GREATER THAN THIS
C     VALUE.
C -4  LICN NOT LARGE ENOUGH TO CONTINUE WITH THE DECOMPOSITION.
C -5  THE DECOMPOSITION HAS BEEN COMPLETED BUT SOME OF THE LU FACTORS
C     HAVE BEEN DISCARDED TO CREATE ENOUGH ROOM IN A/ICN TO CONTINUE
C     THE DECOMPOSITION. THE VARIABLE MINICN IN COMMON BLOCK MA30F/FD
C     THEN GIVES THE SIZE THAT LICN SHOULD BE TO ENABLE THE
C     FACTORIZATION TO BE SUCCESSFUL.  IF THE USER SETS COMMON BLOCK
C     VARIABLE ABORT3 TO .TRUE., THEN THE SUBROUTINE WILL EXIT
C     IMMEDIATELY INSTEAD OF DESTROYING ANY FACTORS AND CONTINUING.
C -6  BOTH LICN AND LIRN ARE TOO SMALL. TERMINATION HAS BEEN CAUSED BY
C     LACK OF SPACE IN IRN (SEE ERROR IFLAG= -3), BUT ALREADY SOME OF
C     THE LU FACTORS IN A/ICN HAVE BEEN LOST (SEE ERROR IFLAG= -5).
C     MINICN GIVES THE MINIMUM AMOUNT OF SPACE REQUIRED IN A/ICN FOR
C     DECOMPOSITION UP TO THIS POINT.
C
C FOR COMMENTS OF COMMON BLOCK VARIABLES SEE BLOCK DATA SUBPROGRAM.
C     .. Parameters ..
      DOUBLE PRECISION ZERO,UMAX
      PARAMETER (ZERO=0.0D0,UMAX=.999999999D0)
C     ..
C     .. Scalar Arguments ..
      DOUBLE PRECISION U
      INTEGER IFLAG,LICN,LIRN,NN
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(LICN)
      INTEGER ICN(LICN),IDISP(2),IFIRST(NN),IP(NN),IPC(NN),IPTR(NN),
     +        IQ(NN),IRN(LIRN),LASTC(NN),LASTR(NN),LENC(NN),LENR(NN),
     +        LENRL(NN),NEXTC(NN),NEXTR(NN)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION AANEW,AMAX,ANEW,AU,PIVR,PIVRAT,SCALE
      INTEGER COLUPD,DISPC,I,I1,I2,IACTIV,IBEG,IDISPC,IDROP,IDUMMY,IEND,
     +        IFILL,IFIR,II,III,IJFIR,IJP1,IJPOS,ILAST,INDROW,IOP,IPIV,
     +        IPOS,IROWS,ISING,ISRCH,ISTART,ISW,ISW1,ITOP,J,J1,J2,JBEG,
     +        JCOST,JCOUNT,JDIFF,JDUMMY,JEND,JJ,JMORE,JNEW,JNPOS,JOLD,
     +        JPIV,JPOS,JROOM,JVAL,JZER,JZERO,K,KCOST,KDROP,L,LC,LENPIV,
     +        LL,LR,MOREI,MSRCH,N,NBLOCK,NC,NNM1,NR,NUM,NZ,NZ2,NZCOL,
     +        NZMIN,NZPC,NZROW,OLDEND,OLDPIV,PIVEND,PIVOT,PIVROW,ROWI
C     ..
C     .. External Subroutines ..
      EXTERNAL MA30DD
C     ..
C     .. Data block external statement
      EXTERNAL MA30JD
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC DABS,DMAX1,DMIN1,IABS,MAX0,MIN0
C     ..
C     .. Common blocks ..
      COMMON /MA30ED/LP,ABORT1,ABORT2,ABORT3
      COMMON /MA30FD/IRNCP,ICNCP,IRANK,MINIRN,MINICN
      COMMON /MA30ID/TOL,BIG,NDROP,NSRCH,LBIG
      DOUBLE PRECISION BIG,TOL
      INTEGER ICNCP,IRANK,IRNCP,LP,MINICN,MINIRN,NDROP,NSRCH
      LOGICAL ABORT1,ABORT2,ABORT3,LBIG
C     ..
C     .. Save statement ..
      SAVE /MA30ED/,/MA30FD/,/MA30ID/
C     ..
C     .. Executable Statements ..
      MSRCH = NSRCH
      NDROP = 0
      MINIRN = 0
      MINICN = IDISP(1) - 1
      MOREI = 0
      IRANK = NN
      IRNCP = 0
      ICNCP = 0
      IFLAG = 0
C RESET U IF NECESSARY.
      U = DMIN1(U,UMAX)
C IBEG IS THE POSITION OF THE NEXT PIVOT ROW AFTER ELIMINATION STEP
C     USING IT.
      U = DMAX1(U,ZERO)
      IBEG = IDISP(1)
C IACTIV IS THE POSITION OF THE FIRST ENTRY IN THE ACTIVE PART OF A/ICN.
      IACTIV = IDISP(2)
C NZROW IS CURRENT NUMBER OF NON-ZEROS IN ACTIVE AND UNPROCESSED PART
C     OF ROW FILE ICN.
      NZROW = LICN - IACTIV + 1
      MINICN = NZROW + MINICN
C
C COUNT THE NUMBER OF DIAGONAL BLOCKS AND SET UP POINTERS TO THE
C     BEGINNINGS OF THE ROWS.
C NUM IS THE NUMBER OF DIAGONAL BLOCKS.
      NUM = 1
      IPTR(1) = IACTIV
      IF (NN.EQ.1) GO TO 20
      NNM1 = NN - 1
      DO 10 I = 1,NNM1
        IF (IP(I).LT.0) NUM = NUM + 1
        IPTR(I+1) = IPTR(I) + LENR(I)
   10 CONTINUE
C ILAST IS THE LAST ROW IN THE PREVIOUS BLOCK.
   20 ILAST = 0
C
C ***********************************************
C ****    LU DECOMPOSITION OF BLOCK NBLOCK   ****
C ***********************************************
C
C EACH PASS THROUGH THIS LOOP PERFORMS LU DECOMPOSITION ON ONE
C     OF THE DIAGONAL BLOCKS.
      DO 1000 NBLOCK = 1,NUM
        ISTART = ILAST + 1
        DO 30 IROWS = ISTART,NN
          IF (IP(IROWS).LT.0) GO TO 40
   30   CONTINUE
        IROWS = NN
   40   ILAST = IROWS
C N IS THE NUMBER OF ROWS IN THE CURRENT BLOCK.
C ISTART IS THE INDEX OF THE FIRST ROW IN THE CURRENT BLOCK.
C ILAST IS THE INDEX OF THE LAST ROW IN THE CURRENT BLOCK.
C IACTIV IS THE POSITION OF THE FIRST ENTRY IN THE BLOCK.
C ITOP IS THE POSITION OF THE LAST ENTRY IN THE BLOCK.
        N = ILAST - ISTART + 1
        IF (N.NE.1) GO TO 90
C
C CODE FOR DEALING WITH 1X1 BLOCK.
        LENRL(ILAST) = 0
        ISING = ISTART
        IF (LENR(ILAST).NE.0) GO TO 50
C BLOCK IS STRUCTURALLY SINGULAR.
        IRANK = IRANK - 1
        ISING = -ISING
        IF (IFLAG.NE.2 .AND. IFLAG.NE.-5) IFLAG = 1
        IF (.NOT.ABORT1) GO TO 80
        IDISP(2) = IACTIV
        IFLAG = -1
        IF (LP.NE.0) WRITE (LP,FMT=99999)
C     RETURN
        GO TO 1120

   50   SCALE = DABS(A(IACTIV))
        IF (SCALE.EQ.ZERO) GO TO 60
        IF (LBIG) BIG = DMAX1(BIG,SCALE)
        GO TO 70

   60   ISING = -ISING
        IRANK = IRANK - 1
        IPTR(ILAST) = 0
        IF (IFLAG.NE.-5) IFLAG = 2
        IF (.NOT.ABORT2) GO TO 70
        IDISP(2) = IACTIV
        IFLAG = -2
        IF (LP.NE.0) WRITE (LP,FMT=99998)
        GO TO 1120

   70   A(IBEG) = A(IACTIV)
        ICN(IBEG) = ICN(IACTIV)
        IACTIV = IACTIV + 1
        IPTR(ISTART) = 0
        IBEG = IBEG + 1
        NZROW = NZROW - 1
   80   LASTR(ISTART) = ISTART
        IPC(ISTART) = -ISING
        GO TO 1000
C
C NON-TRIVIAL BLOCK.
   90   ITOP = LICN
        IF (ILAST.NE.NN) ITOP = IPTR(ILAST+1) - 1
C
C SET UP COLUMN ORIENTED STORAGE.
        DO 100 I = ISTART,ILAST
          LENRL(I) = 0
          LENC(I) = 0
  100   CONTINUE
        IF (ITOP-IACTIV.LT.LIRN) GO TO 110
        MINIRN = ITOP - IACTIV + 1
        PIVOT = ISTART - 1
        GO TO 1100
C
C CALCULATE COLUMN COUNTS.
  110   DO 120 II = IACTIV,ITOP
          I = ICN(II)
          LENC(I) = LENC(I) + 1
  120   CONTINUE
C SET UP COLUMN POINTERS SO THAT IPC(J) POINTS TO POSITION AFTER END
C     OF COLUMN J IN COLUMN FILE.
        IPC(ILAST) = LIRN + 1
        J1 = ISTART + 1
        DO 130 JJ = J1,ILAST
          J = ILAST - JJ + J1 - 1
          IPC(J) = IPC(J+1) - LENC(J+1)
  130   CONTINUE
        DO 150 INDROW = ISTART,ILAST
          J1 = IPTR(INDROW)
          J2 = J1 + LENR(INDROW) - 1
          IF (J1.GT.J2) GO TO 150
          DO 140 JJ = J1,J2
            J = ICN(JJ)
            IPOS = IPC(J) - 1
            IRN(IPOS) = INDROW
            IPC(J) = IPOS
  140     CONTINUE
  150   CONTINUE
C DISPC IS THE LOWEST INDEXED ACTIVE LOCATION IN THE COLUMN FILE.
        DISPC = IPC(ISTART)
        NZCOL = LIRN - DISPC + 1
        MINIRN = MAX0(NZCOL,MINIRN)
        NZMIN = 1
C
C INITIALIZE ARRAY IFIRST.  IFIRST(I) = +/- K INDICATES THAT ROW/COL
C     K HAS I NON-ZEROS.  IF IFIRST(I) = 0, THERE IS NO ROW OR COLUMN
C     WITH I NON ZEROS.
        DO 160 I = 1,N
          IFIRST(I) = 0
  160   CONTINUE
C
C COMPUTE ORDERING OF ROW AND COLUMN COUNTS.
C FIRST RUN THROUGH COLUMNS (FROM COLUMN N TO COLUMN 1).
        DO 180 JJ = ISTART,ILAST
          J = ILAST - JJ + ISTART
          NZ = LENC(J)
          IF (NZ.NE.0) GO TO 170
          IPC(J) = 0
          GO TO 180

  170     IF (NSRCH.LE.NN) GO TO 180
          ISW = IFIRST(NZ)
          IFIRST(NZ) = -J
          LASTC(J) = 0
          NEXTC(J) = -ISW
          ISW1 = IABS(ISW)
          IF (ISW.NE.0) LASTC(ISW1) = J
  180   CONTINUE
C NOW RUN THROUGH ROWS (AGAIN FROM N TO 1).
        DO 210 II = ISTART,ILAST
          I = ILAST - II + ISTART
          NZ = LENR(I)
          IF (NZ.NE.0) GO TO 190
          IPTR(I) = 0
          LASTR(I) = 0
          GO TO 210

  190     ISW = IFIRST(NZ)
          IFIRST(NZ) = I
          IF (ISW.GT.0) GO TO 200
          NEXTR(I) = 0
          LASTR(I) = ISW
          GO TO 210

  200     NEXTR(I) = ISW
          LASTR(I) = LASTR(ISW)
          LASTR(ISW) = I
  210   CONTINUE
C
C
C **********************************************
C ****    START OF MAIN ELIMINATION LOOP    ****
C **********************************************
        DO 980 PIVOT = ISTART,ILAST
C
C FIRST FIND THE PIVOT USING MARKOWITZ CRITERION WITH STABILITY
C     CONTROL.
C JCOST IS THE MARKOWITZ COST OF THE BEST PIVOT SO FAR,.. THIS
C     PIVOT IS IN ROW IPIV AND COLUMN JPIV.
          NZ2 = NZMIN
C HUGE IS THE FORTRAN 90 INTRINSIC FOR THE LARGEST INTEGER
          JCOST = HUGE(N)

C
C EXAMINE ROWS/COLUMNS IN ORDER OF ASCENDING COUNT.
          DO 340 L = 1,2
            PIVRAT = ZERO
            ISRCH = 1
            LL = L
C A PASS WITH L EQUAL TO 2 IS ONLY PERFORMED IN THE CASE OF SINGULARITY.
            DO 330 NZ = NZ2,N
              IF (JCOST.LE. (NZ-1)**2) GO TO 420
              IJFIR = IFIRST(NZ)
              IF (IJFIR) 230,220,240
  220         IF (LL.EQ.1) NZMIN = NZ + 1
              GO TO 330

  230         LL = 2
              IJFIR = -IJFIR
              GO TO 290

  240         LL = 2
C SCAN ROWS WITH NZ NON-ZEROS.
              DO 270 IDUMMY = 1,N
                IF (JCOST.LE. (NZ-1)**2) GO TO 420
                IF (ISRCH.GT.MSRCH) GO TO 420
                IF (IJFIR.EQ.0) GO TO 280
C ROW IJFIR IS NOW EXAMINED.
                I = IJFIR
                IJFIR = NEXTR(I)
C FIRST CALCULATE MULTIPLIER THRESHOLD LEVEL.
                AMAX = ZERO
                J1 = IPTR(I) + LENRL(I)
                J2 = IPTR(I) + LENR(I) - 1
                DO 250 JJ = J1,J2
                  AMAX = DMAX1(AMAX,DABS(A(JJ)))
  250           CONTINUE
                AU = AMAX*U
                ISRCH = ISRCH + 1
C SCAN ROW FOR POSSIBLE PIVOTS
                DO 260 JJ = J1,J2
                  IF (DABS(A(JJ)).LE.AU .AND. L.EQ.1) GO TO 260
                  J = ICN(JJ)
                  KCOST = (NZ-1)* (LENC(J)-1)
                  IF (KCOST.GT.JCOST) GO TO 260
                  PIVR = ZERO
                  IF (AMAX.NE.ZERO) PIVR = DABS(A(JJ))/AMAX
                  IF (KCOST.EQ.JCOST .AND. (PIVR.LE.PIVRAT.OR.
     +                NSRCH.GT.NN+1)) GO TO 260
C BEST PIVOT SO FAR IS FOUND.
                  JCOST = KCOST
                  IJPOS = JJ
                  IPIV = I
                  JPIV = J
                  IF (MSRCH.GT.NN+1 .AND. JCOST.LE. (NZ-1)**2) GO TO 420
                  PIVRAT = PIVR
  260           CONTINUE
  270         CONTINUE
C
C COLUMNS WITH NZ NON-ZEROS NOW EXAMINED.
  280         IJFIR = IFIRST(NZ)
              IJFIR = -LASTR(IJFIR)
  290         IF (JCOST.LE.NZ* (NZ-1)) GO TO 420
              IF (MSRCH.LE.NN) GO TO 330
              DO 320 IDUMMY = 1,N
                IF (IJFIR.EQ.0) GO TO 330
                J = IJFIR
                IJFIR = NEXTC(IJFIR)
                I1 = IPC(J)
                I2 = I1 + NZ - 1
C SCAN COLUMN J.
                DO 310 II = I1,I2
                  I = IRN(II)
                  KCOST = (NZ-1)* (LENR(I)-LENRL(I)-1)
                  IF (KCOST.GE.JCOST) GO TO 310
C PIVOT HAS BEST MARKOWITZ COUNT SO FAR ... NOW CHECK ITS
C     SUITABILITY ON NUMERIC GROUNDS BY EXAMINING THE OTHER NON-ZEROS
C     IN ITS ROW.
                  J1 = IPTR(I) + LENRL(I)
                  J2 = IPTR(I) + LENR(I) - 1
C WE NEED A STABILITY CHECK ON SINGLETON COLUMNS BECAUSE OF POSSIBLE
C     PROBLEMS WITH UNDERDETERMINED SYSTEMS.
                  AMAX = ZERO
                  DO 300 JJ = J1,J2
                    AMAX = DMAX1(AMAX,DABS(A(JJ)))
                    IF (ICN(JJ).EQ.J) JPOS = JJ
  300             CONTINUE
                  IF (DABS(A(JPOS)).LE.AMAX*U .AND. L.EQ.1) GO TO 310
                  JCOST = KCOST
                  IPIV = I
                  JPIV = J
                  IJPOS = JPOS
                  IF (AMAX.NE.ZERO) PIVRAT = DABS(A(JPOS))/AMAX
                  IF (JCOST.LE.NZ* (NZ-1)) GO TO 420
  310           CONTINUE
C
  320         CONTINUE
C
  330       CONTINUE
C IN THE EVENT OF SINGULARITY, WE MUST MAKE SURE ALL ROWS AND COLUMNS
C ARE TESTED.
            MSRCH = N
C
C MATRIX IS NUMERICALLY OR STRUCTURALLY SINGULAR  ... WHICH IT IS WILL
C     BE DIAGNOSED LATER.
            IRANK = IRANK - 1
  340     CONTINUE
C ASSIGN REST OF ROWS AND COLUMNS TO ORDERING ARRAY.
C MATRIX IS STRUCTURALLY SINGULAR.
          IF (IFLAG.NE.2 .AND. IFLAG.NE.-5) IFLAG = 1
          IRANK = IRANK - ILAST + PIVOT + 1
          IF (.NOT.ABORT1) GO TO 350
          IDISP(2) = IACTIV
          IFLAG = -1
          IF (LP.NE.0) WRITE (LP,FMT=99999)
          GO TO 1120

  350     K = PIVOT - 1
          DO 390 I = ISTART,ILAST
            IF (LASTR(I).NE.0) GO TO 390
            K = K + 1
            LASTR(I) = K
            IF (LENRL(I).EQ.0) GO TO 380
            MINICN = MAX0(MINICN,NZROW+IBEG-1+MOREI+LENRL(I))
            IF (IACTIV-IBEG.GE.LENRL(I)) GO TO 360
            CALL MA30DD(A,ICN,IPTR(ISTART),N,IACTIV,ITOP,.TRUE.)
C CHECK NOW TO SEE IF MA30D/DD HAS CREATED ENOUGH AVAILABLE SPACE.
            IF (IACTIV-IBEG.GE.LENRL(I)) GO TO 360
C CREATE MORE SPACE BY DESTROYING PREVIOUSLY CREATED LU FACTORS.
            MOREI = MOREI + IBEG - IDISP(1)
            IBEG = IDISP(1)
            IF (LP.NE.0) WRITE (LP,FMT=99997)
            IFLAG = -5
            IF (ABORT3) GO TO 1090
  360       J1 = IPTR(I)
            J2 = J1 + LENRL(I) - 1
            IPTR(I) = 0
            DO 370 JJ = J1,J2
              A(IBEG) = A(JJ)
              ICN(IBEG) = ICN(JJ)
              ICN(JJ) = 0
              IBEG = IBEG + 1
  370       CONTINUE
            NZROW = NZROW - LENRL(I)
  380       IF (K.EQ.ILAST) GO TO 400
  390     CONTINUE
  400     K = PIVOT - 1
          DO 410 I = ISTART,ILAST
            IF (IPC(I).NE.0) GO TO 410
            K = K + 1
            IPC(I) = K
            IF (K.EQ.ILAST) GO TO 990
  410     CONTINUE
C
C THE PIVOT HAS NOW BEEN FOUND IN POSITION (IPIV,JPIV) IN LOCATION
C     IJPOS IN ROW FILE.
C UPDATE COLUMN AND ROW ORDERING ARRAYS TO CORRESPOND WITH REMOVAL
C     OF THE ACTIVE PART OF THE MATRIX.
  420     ISING = PIVOT
          IF (A(IJPOS).NE.ZERO) GO TO 430
C NUMERICAL SINGULARITY IS RECORDED HERE.
          ISING = -ISING
          IF (IFLAG.NE.-5) IFLAG = 2
          IF (.NOT.ABORT2) GO TO 430
          IDISP(2) = IACTIV
          IFLAG = -2
          IF (LP.NE.0) WRITE (LP,FMT=99998)
          GO TO 1120

  430     OLDPIV = IPTR(IPIV) + LENRL(IPIV)
          OLDEND = IPTR(IPIV) + LENR(IPIV) - 1
C CHANGES TO COLUMN ORDERING.
          IF (NSRCH.LE.NN) GO TO 460
          COLUPD = NN + 1
          DO 450 JJ = OLDPIV,OLDEND
            J = ICN(JJ)
            LC = LASTC(J)
            NC = NEXTC(J)
            NEXTC(J) = -COLUPD
            IF (JJ.NE.IJPOS) COLUPD = J
            IF (NC.NE.0) LASTC(NC) = LC
            IF (LC.EQ.0) GO TO 440
            NEXTC(LC) = NC
            GO TO 450

  440       NZ = LENC(J)
            ISW = IFIRST(NZ)
            IF (ISW.GT.0) LASTR(ISW) = -NC
            IF (ISW.LT.0) IFIRST(NZ) = -NC
  450     CONTINUE
C CHANGES TO ROW ORDERING.
  460     I1 = IPC(JPIV)
          I2 = I1 + LENC(JPIV) - 1
          DO 480 II = I1,I2
            I = IRN(II)
            LR = LASTR(I)
            NR = NEXTR(I)
            IF (NR.NE.0) LASTR(NR) = LR
            IF (LR.LE.0) GO TO 470
            NEXTR(LR) = NR
            GO TO 480

  470       NZ = LENR(I) - LENRL(I)
            IF (NR.NE.0) IFIRST(NZ) = NR
            IF (NR.EQ.0) IFIRST(NZ) = LR
  480     CONTINUE
C
C MOVE PIVOT TO POSITION LENRL+1 IN PIVOT ROW AND MOVE PIVOT ROW
C     TO THE BEGINNING OF THE AVAILABLE STORAGE.
C THE L PART AND THE PIVOT IN THE OLD COPY OF THE PIVOT ROW IS
C     NULLIFIED WHILE, IN THE STRICTLY UPPER TRIANGULAR PART, THE
C     COLUMN INDICES, J SAY, ARE OVERWRITTEN BY THE CORRESPONDING
C     ENTRY OF IQ (IQ(J)) AND IQ(J) IS SET TO THE NEGATIVE OF THE
C     DISPLACEMENT OF THE COLUMN INDEX FROM THE PIVOT ENTRY.
          IF (OLDPIV.EQ.IJPOS) GO TO 490
          AU = A(OLDPIV)
          A(OLDPIV) = A(IJPOS)
          A(IJPOS) = AU
          ICN(IJPOS) = ICN(OLDPIV)
          ICN(OLDPIV) = JPIV
C CHECK TO SEE IF THERE IS SPACE IMMEDIATELY AVAILABLE IN A/ICN TO
C     HOLD NEW COPY OF PIVOT ROW.
  490     MINICN = MAX0(MINICN,NZROW+IBEG-1+MOREI+LENR(IPIV))
          IF (IACTIV-IBEG.GE.LENR(IPIV)) GO TO 500
          CALL MA30DD(A,ICN,IPTR(ISTART),N,IACTIV,ITOP,.TRUE.)
          OLDPIV = IPTR(IPIV) + LENRL(IPIV)
          OLDEND = IPTR(IPIV) + LENR(IPIV) - 1
C CHECK NOW TO SEE IF MA30D/DD HAS CREATED ENOUGH AVAILABLE SPACE.
          IF (IACTIV-IBEG.GE.LENR(IPIV)) GO TO 500
C CREATE MORE SPACE BY DESTROYING PREVIOUSLY CREATED LU FACTORS.
          MOREI = MOREI + IBEG - IDISP(1)
          IBEG = IDISP(1)
          IF (LP.NE.0) WRITE (LP,FMT=99997)
          IFLAG = -5
          IF (ABORT3) GO TO 1090
          IF (IACTIV-IBEG.GE.LENR(IPIV)) GO TO 500
C THERE IS STILL NOT ENOUGH ROOM IN A/ICN.
          IFLAG = -4
          GO TO 1090
C COPY PIVOT ROW AND SET UP IQ ARRAY.
  500     IJPOS = 0
          J1 = IPTR(IPIV)
C
          DO 530 JJ = J1,OLDEND
            A(IBEG) = A(JJ)
            ICN(IBEG) = ICN(JJ)
            IF (IJPOS.NE.0) GO TO 510
            IF (ICN(JJ).EQ.JPIV) IJPOS = IBEG
            ICN(JJ) = 0
            GO TO 520

  510       K = IBEG - IJPOS
            J = ICN(JJ)
            ICN(JJ) = IQ(J)
            IQ(J) = -K
  520       IBEG = IBEG + 1
  530     CONTINUE
C
          IJP1 = IJPOS + 1
          PIVEND = IBEG - 1
          LENPIV = PIVEND - IJPOS
          NZROW = NZROW - LENRL(IPIV) - 1
          IPTR(IPIV) = OLDPIV + 1
          IF (LENPIV.EQ.0) IPTR(IPIV) = 0
C
C REMOVE PIVOT ROW (INCLUDING PIVOT) FROM COLUMN ORIENTED FILE.
          DO 560 JJ = IJPOS,PIVEND
            J = ICN(JJ)
            I1 = IPC(J)
            LENC(J) = LENC(J) - 1
C I2 IS LAST POSITION IN NEW COLUMN.
            I2 = IPC(J) + LENC(J) - 1
            IF (I2.LT.I1) GO TO 550
            DO 540 II = I1,I2
              IF (IRN(II).NE.IPIV) GO TO 540
              IRN(II) = IRN(I2+1)
              GO TO 550

  540       CONTINUE
  550       IRN(I2+1) = 0
  560     CONTINUE
          NZCOL = NZCOL - LENPIV - 1
C
C GO DOWN THE PIVOT COLUMN AND FOR EACH ROW WITH A NON-ZERO ADD
C     THE APPROPRIATE MULTIPLE OF THE PIVOT ROW TO IT.
C WE LOOP ON THE NUMBER OF NON-ZEROS IN THE PIVOT COLUMN SINCE
C     MA30D/DD MAY CHANGE ITS ACTUAL POSITION.
C
          NZPC = LENC(JPIV)
          IF (NZPC.EQ.0) GO TO 900
          DO 840 III = 1,NZPC
            II = IPC(JPIV) + III - 1
            I = IRN(II)
C SEARCH ROW I FOR NON-ZERO TO BE ELIMINATED, CALCULATE MULTIPLIER,
C     AND PLACE IT IN POSITION LENRL+1 IN ITS ROW.
C  IDROP IS THE NUMBER OF NON-ZERO ENTRIES DROPPED FROM ROW    I
C        BECAUSE THESE FALL BENEATH TOLERANCE LEVEL.
C
            IDROP = 0
            J1 = IPTR(I) + LENRL(I)
            IEND = IPTR(I) + LENR(I) - 1
            DO 570 JJ = J1,IEND
              IF (ICN(JJ).NE.JPIV) GO TO 570
C IF PIVOT IS ZERO, REST OF COLUMN IS AND SO MULTIPLIER IS ZERO.
              AU = ZERO
              IF (A(IJPOS).NE.ZERO) AU = -A(JJ)/A(IJPOS)
              IF (LBIG) BIG = DMAX1(BIG,DABS(AU))
              A(JJ) = A(J1)
              A(J1) = AU
              ICN(JJ) = ICN(J1)
              ICN(J1) = JPIV
              LENRL(I) = LENRL(I) + 1
              GO TO 580

  570       CONTINUE
C JUMP IF PIVOT ROW IS A SINGLETON.
  580       IF (LENPIV.EQ.0) GO TO 840
C NOW PERFORM NECESSARY OPERATIONS ON REST OF NON-PIVOT ROW I.
            ROWI = J1 + 1
            IOP = 0
C JUMP IF ALL THE PIVOT ROW CAUSES FILL-IN.
            IF (ROWI.GT.IEND) GO TO 650
C PERFORM OPERATIONS ON CURRENT NON-ZEROS IN ROW I.
C INNERMOST LOOP.
            DO 590 JJ = ROWI,IEND
              J = ICN(JJ)
              IF (IQ(J).GT.0) GO TO 590
              IOP = IOP + 1
              PIVROW = IJPOS - IQ(J)
              A(JJ) = A(JJ) + AU*A(PIVROW)
              IF (LBIG) BIG = DMAX1(DABS(A(JJ)),BIG)
              ICN(PIVROW) = -ICN(PIVROW)
              IF (DABS(A(JJ)).LT.TOL) IDROP = IDROP + 1
  590       CONTINUE
C
C  JUMP IF NO NON-ZEROS IN NON-PIVOT ROW HAVE BEEN REMOVED
C       BECAUSE THESE ARE BENEATH THE DROP-TOLERANCE  TOL.
C
            IF (IDROP.EQ.0) GO TO 650
C
C  RUN THROUGH NON-PIVOT ROW COMPRESSING ROW SO THAT ONLY
C      NON-ZEROS GREATER THAN   TOL   ARE STORED.  ALL NON-ZEROS
C      LESS THAN   TOL   ARE ALSO REMOVED FROM THE COLUMN STRUCTURE.
C
            JNEW = ROWI
            DO 630 JJ = ROWI,IEND
              IF (DABS(A(JJ)).LT.TOL) GO TO 600
              A(JNEW) = A(JJ)
              ICN(JNEW) = ICN(JJ)
              JNEW = JNEW + 1
              GO TO 630
C
C  REMOVE NON-ZERO ENTRY FROM COLUMN STRUCTURE.
C
  600         J = ICN(JJ)
              I1 = IPC(J)
              I2 = I1 + LENC(J) - 1
              DO 610 II = I1,I2
                IF (IRN(II).EQ.I) GO TO 620
  610         CONTINUE
  620         IRN(II) = IRN(I2)
              IRN(I2) = 0
              LENC(J) = LENC(J) - 1
              IF (NSRCH.LE.NN) GO TO 630
C REMOVE COLUMN FROM COLUMN CHAIN AND PLACE IN UPDATE CHAIN.
              IF (NEXTC(J).LT.0) GO TO 630
C JUMP IF COLUMN ALREADY IN UPDATE CHAIN.
              LC = LASTC(J)
              NC = NEXTC(J)
              NEXTC(J) = -COLUPD
              COLUPD = J
              IF (NC.NE.0) LASTC(NC) = LC
              IF (LC.EQ.0) GO TO 622
              NEXTC(LC) = NC
              GO TO 630

  622         NZ = LENC(J) + 1
              ISW = IFIRST(NZ)
              IF (ISW.GT.0) LASTR(ISW) = -NC
              IF (ISW.LT.0) IFIRST(NZ) = -NC
  630       CONTINUE
            DO 640 JJ = JNEW,IEND
              ICN(JJ) = 0
  640       CONTINUE
C THE VALUE OF IDROP MIGHT BE DIFFERENT FROM THAT CALCULATED EARLIER
C     BECAUSE, WE MAY NOW HAVE DROPPED SOME NON-ZEROS WHICH WERE NOT
C     MODIFIED BY THE PIVOT ROW.
            IDROP = IEND + 1 - JNEW
            IEND = JNEW - 1
            LENR(I) = LENR(I) - IDROP
            NZROW = NZROW - IDROP
            NZCOL = NZCOL - IDROP
            NDROP = NDROP + IDROP
  650       IFILL = LENPIV - IOP
C JUMP IS IF THERE IS NO FILL-IN.
            IF (IFILL.EQ.0) GO TO 750
C NOW FOR THE FILL-IN.
            MINICN = MAX0(MINICN,MOREI+IBEG-1+NZROW+IFILL+LENR(I))
C SEE IF THERE IS ROOM FOR FILL-IN.
C GET MAXIMUM SPACE FOR ROW I IN SITU.
            DO 660 JDIFF = 1,IFILL
              JNPOS = IEND + JDIFF
              IF (JNPOS.GT.LICN) GO TO 670
              IF (ICN(JNPOS).NE.0) GO TO 670
  660       CONTINUE
C THERE IS ROOM FOR ALL THE FILL-IN AFTER THE END OF THE ROW SO IT
C     CAN BE LEFT IN SITU.
C NEXT AVAILABLE SPACE FOR FILL-IN.
            IEND = IEND + 1
            GO TO 750
C JMORE SPACES FOR FILL-IN ARE REQUIRED IN FRONT OF ROW.
  670       JMORE = IFILL - JDIFF + 1
            I1 = IPTR(I)
C WE NOW LOOK IN FRONT OF THE ROW TO SEE IF THERE IS SPACE FOR
C     THE REST OF THE FILL-IN.
            DO 680 JDIFF = 1,JMORE
              JNPOS = I1 - JDIFF
              IF (JNPOS.LT.IACTIV) GO TO 690
              IF (ICN(JNPOS).NE.0) GO TO 700
  680       CONTINUE
  690       JNPOS = I1 - JMORE
            GO TO 710
C WHOLE ROW MUST BE MOVED TO THE BEGINNING OF AVAILABLE STORAGE.
  700       JNPOS = IACTIV - LENR(I) - IFILL
C JUMP IF THERE IS SPACE IMMEDIATELY AVAILABLE FOR THE SHIFTED ROW.
  710       IF (JNPOS.GE.IBEG) GO TO 730
            CALL MA30DD(A,ICN,IPTR(ISTART),N,IACTIV,ITOP,.TRUE.)
            I1 = IPTR(I)
            IEND = I1 + LENR(I) - 1
            JNPOS = IACTIV - LENR(I) - IFILL
            IF (JNPOS.GE.IBEG) GO TO 730
C NO SPACE AVAILABLE SO TRY TO CREATE SOME BY THROWING AWAY PREVIOUS
C     LU DECOMPOSITION.
            MOREI = MOREI + IBEG - IDISP(1) - LENPIV - 1
            IF (LP.NE.0) WRITE (LP,FMT=99997)
            IFLAG = -5
            IF (ABORT3) GO TO 1090
C KEEP RECORD OF CURRENT PIVOT ROW.
            IBEG = IDISP(1)
            ICN(IBEG) = JPIV
            A(IBEG) = A(IJPOS)
            IJPOS = IBEG
            DO 720 JJ = IJP1,PIVEND
              IBEG = IBEG + 1
              A(IBEG) = A(JJ)
              ICN(IBEG) = ICN(JJ)
  720       CONTINUE
            IJP1 = IJPOS + 1
            PIVEND = IBEG
            IBEG = IBEG + 1
            IF (JNPOS.GE.IBEG) GO TO 730
C THIS STILL DOES NOT GIVE ENOUGH ROOM.
            IFLAG = -4
            GO TO 1090

  730       IACTIV = MIN0(IACTIV,JNPOS)
C MOVE NON-PIVOT ROW I.
            IPTR(I) = JNPOS
            DO 740 JJ = I1,IEND
              A(JNPOS) = A(JJ)
              ICN(JNPOS) = ICN(JJ)
              JNPOS = JNPOS + 1
              ICN(JJ) = 0
  740       CONTINUE
C FIRST NEW AVAILABLE SPACE.
            IEND = JNPOS
  750       NZROW = NZROW + IFILL
C INNERMOST FILL-IN LOOP WHICH ALSO RESETS ICN.
            IDROP = 0
            DO 830 JJ = IJP1,PIVEND
              J = ICN(JJ)
              IF (J.LT.0) GO TO 820
              ANEW = AU*A(JJ)
              AANEW = DABS(ANEW)
              IF (AANEW.GE.TOL) GO TO 760
              IDROP = IDROP + 1
              NDROP = NDROP + 1
              NZROW = NZROW - 1
              MINICN = MINICN - 1
              IFILL = IFILL - 1
              GO TO 830

  760         IF (LBIG) BIG = DMAX1(AANEW,BIG)
              A(IEND) = ANEW
              ICN(IEND) = J
              IEND = IEND + 1
C
C PUT NEW ENTRY IN COLUMN FILE.
              MINIRN = MAX0(MINIRN,NZCOL+LENC(J)+1)
              JEND = IPC(J) + LENC(J)
              JROOM = NZPC - III + 1 + LENC(J)
              IF (JEND.GT.LIRN) GO TO 770
              IF (IRN(JEND).EQ.0) GO TO 810
  770         IF (JROOM.LT.DISPC) GO TO 780
C COMPRESS COLUMN FILE TO OBTAIN SPACE FOR NEW COPY OF COLUMN.
              CALL MA30DD(A,IRN,IPC(ISTART),N,DISPC,LIRN,.FALSE.)
              IF (JROOM.LT.DISPC) GO TO 780
              JROOM = DISPC - 1
              IF (JROOM.GE.LENC(J)+1) GO TO 780
C COLUMN FILE IS NOT LARGE ENOUGH.
              GO TO 1100
C COPY COLUMN TO BEGINNING OF FILE.
  780         JBEG = IPC(J)
              JEND = IPC(J) + LENC(J) - 1
              JZERO = DISPC - 1
              DISPC = DISPC - JROOM
              IDISPC = DISPC
              DO 790 II = JBEG,JEND
                IRN(IDISPC) = IRN(II)
                IRN(II) = 0
                IDISPC = IDISPC + 1
  790         CONTINUE
              IPC(J) = DISPC
              JEND = IDISPC
              DO 800 II = JEND,JZERO
                IRN(II) = 0
  800         CONTINUE
  810         IRN(JEND) = I
              NZCOL = NZCOL + 1
              LENC(J) = LENC(J) + 1
C END OF ADJUSTMENT TO COLUMN FILE.
              GO TO 830
C
  820         ICN(JJ) = -J
  830       CONTINUE
            IF (IDROP.EQ.0) GO TO 834
            DO 832 KDROP = 1,IDROP
              ICN(IEND) = 0
              IEND = IEND + 1
  832       CONTINUE
  834       LENR(I) = LENR(I) + IFILL
C END OF SCAN OF PIVOT COLUMN.
  840     CONTINUE
C
C
C REMOVE PIVOT COLUMN FROM COLUMN ORIENTED STORAGE AND UPDATE ROW
C     ORDERING ARRAYS.
          I1 = IPC(JPIV)
          I2 = IPC(JPIV) + LENC(JPIV) - 1
          NZCOL = NZCOL - LENC(JPIV)
          DO 890 II = I1,I2
            I = IRN(II)
            IRN(II) = 0
            NZ = LENR(I) - LENRL(I)
            IF (NZ.NE.0) GO TO 850
            LASTR(I) = 0
            GO TO 890

  850       IFIR = IFIRST(NZ)
            IFIRST(NZ) = I
            IF (IFIR) 860,880,870
  860       LASTR(I) = IFIR
            NEXTR(I) = 0
            GO TO 890

  870       LASTR(I) = LASTR(IFIR)
            NEXTR(I) = IFIR
            LASTR(IFIR) = I
            GO TO 890

  880       LASTR(I) = 0
            NEXTR(I) = 0
            NZMIN = MIN0(NZMIN,NZ)
  890     CONTINUE
C RESTORE IQ AND NULLIFY U PART OF OLD PIVOT ROW.
C    RECORD THE COLUMN PERMUTATION IN LASTC(JPIV) AND THE ROW
C    PERMUTATION IN LASTR(IPIV).
  900     IPC(JPIV) = -ISING
          LASTR(IPIV) = PIVOT
          IF (LENPIV.EQ.0) GO TO 980
          NZROW = NZROW - LENPIV
          JVAL = IJP1
          JZER = IPTR(IPIV)
          IPTR(IPIV) = 0
          DO 910 JCOUNT = 1,LENPIV
            J = ICN(JVAL)
            IQ(J) = ICN(JZER)
            ICN(JZER) = 0
            JVAL = JVAL + 1
            JZER = JZER + 1
  910     CONTINUE
C ADJUST COLUMN ORDERING ARRAYS.
          IF (NSRCH.GT.NN) GO TO 920
          DO 916 JJ = IJP1,PIVEND
            J = ICN(JJ)
            NZ = LENC(J)
            IF (NZ.NE.0) GO TO 914
            IPC(J) = 0
            GO TO 916

  914       NZMIN = MIN0(NZMIN,NZ)
  916     CONTINUE
          GO TO 980

  920     JJ = COLUPD
          DO 970 JDUMMY = 1,NN
            J = JJ
            IF (J.EQ.NN+1) GO TO 980
            JJ = -NEXTC(J)
            NZ = LENC(J)
            IF (NZ.NE.0) GO TO 924
            IPC(J) = 0
            GO TO 970

  924       IFIR = IFIRST(NZ)
            LASTC(J) = 0
            IF (IFIR) 930,940,950
  930       IFIRST(NZ) = -J
            IFIR = -IFIR
            LASTC(IFIR) = J
            NEXTC(J) = IFIR
            GO TO 970

  940       IFIRST(NZ) = -J
            NEXTC(J) = 0
            GO TO 960

  950       LC = -LASTR(IFIR)
            LASTR(IFIR) = -J
            NEXTC(J) = LC
            IF (LC.NE.0) LASTC(LC) = J
  960       NZMIN = MIN0(NZMIN,NZ)
  970     CONTINUE
  980   CONTINUE
C ********************************************
C ****    END OF MAIN ELIMINATION LOOP    ****
C ********************************************
C
C RESET IACTIV TO POINT TO THE BEGINNING OF THE NEXT BLOCK.
  990   IF (ILAST.NE.NN) IACTIV = IPTR(ILAST+1)
 1000 CONTINUE
C
C ********************************************
C ****    END OF DEOMPOSITION OF BLOCK    ****
C ********************************************
C
C RECORD SINGULARITY (IF ANY) IN IQ ARRAY.
      IF (IRANK.EQ.NN) GO TO 1020
      DO 1010 I = 1,NN
        IF (IPC(I).LT.0) GO TO 1010
        ISING = IPC(I)
        IQ(ISING) = -IQ(ISING)
        IPC(I) = -ISING
 1010 CONTINUE
C
C RUN THROUGH LU DECOMPOSITION CHANGING COLUMN INDICES TO THAT OF NEW
C     ORDER AND PERMUTING LENR AND LENRL ARRAYS ACCORDING TO PIVOT
C     PERMUTATIONS.
 1020 ISTART = IDISP(1)
      IEND = IBEG - 1
      IF (IEND.LT.ISTART) GO TO 1040
      DO 1030 JJ = ISTART,IEND
        JOLD = ICN(JJ)
        ICN(JJ) = -IPC(JOLD)
 1030 CONTINUE
 1040 DO 1050 II = 1,NN
        I = LASTR(II)
        NEXTR(I) = LENR(II)
        IPTR(I) = LENRL(II)
 1050 CONTINUE
      DO 1060 I = 1,NN
        LENRL(I) = IPTR(I)
        LENR(I) = NEXTR(I)
 1060 CONTINUE
C
C UPDATE PERMUTATION ARRAYS IP AND IQ.
      DO 1070 II = 1,NN
        I = LASTR(II)
        J = -IPC(II)
        NEXTR(I) = IABS(IP(II)+0)
        IPTR(J) = IABS(IQ(II)+0)
 1070 CONTINUE
      DO 1080 I = 1,NN
        IF (IP(I).LT.0) NEXTR(I) = -NEXTR(I)
        IP(I) = NEXTR(I)
        IF (IQ(I).LT.0) IPTR(I) = -IPTR(I)
        IQ(I) = IPTR(I)
 1080 CONTINUE
      IP(NN) = IABS(IP(NN)+0)
      IDISP(2) = IEND
      GO TO 1120
C
C   ***    ERROR RETURNS    ***
 1090 IDISP(2) = IACTIV
      IF (LP.EQ.0) GO TO 1120
      WRITE (LP,FMT=99996)
      GO TO 1110

 1100 IF (IFLAG.EQ.-5) IFLAG = -6
      IF (IFLAG.NE.-6) IFLAG = -3
      IDISP(2) = IACTIV
      IF (LP.EQ.0) GO TO 1120
      IF (IFLAG.EQ.-3) WRITE (LP,FMT=99995)
      IF (IFLAG.EQ.-6) WRITE (LP,FMT=99994)
 1110 PIVOT = PIVOT - ISTART + 1
      WRITE (LP,FMT=99993) PIVOT,NBLOCK,ISTART,ILAST
      IF (PIVOT.EQ.0) WRITE (LP,FMT=99992) MINIRN
C
C
 1120 RETURN

99999 FORMAT (' ERROR RETURN FROM MA30A/AD BECAUSE MATRIX IS STRUCTUR',
     +       'ALLY SINGULAR')
99998 FORMAT (' ERROR RETURN FROM MA30A/AD BECAUSE MATRIX IS NUMERICA',
     +       'LLY SINGULAR')
99997 FORMAT (' LU DECOMPOSITION DESTROYED TO CREATE MORE SPACE')
99996 FORMAT (' ERROR RETURN FROM MA30A/AD BECAUSE LICN NOT BIG ENOUG',
     +       'H')
99995 FORMAT (' ERROR RETURN FROM MA30A/AD BECAUSE LIRN NOT BIG ENOUG',
     +       'H')
99994 FORMAT (' ERROR RETURN FROM MA30A/AD LIRN AND LICN TOO SMALL')
99993 FORMAT (' AT STAGE ',I5,' IN BLOCK ',I5,' WITH FIRST ROW ',I5,
     +       ' AND LAST ROW ',I5)
99992 FORMAT (' TO CONTINUE SET LIRN TO AT LEAST ',I8)

      END
      SUBROUTINE MA30BD(N,ICN,A,LICN,LENR,LENRL,IDISP,IP,IQ,W,IW,IFLAG)
C MA30B/BD PERFORMS THE LU DECOMPOSITION OF THE DIAGONAL BLOCKS OF A
C     NEW MATRIX PAQ OF THE SAME SPARSITY PATTERN, USING INFORMATION
C     FROM A PREVIOUS CALL TO MA30A/AD. THE ENTRIES OF THE INPUT
C     MATRIX  MUST ALREADY BE IN THEIR FINAL POSITIONS IN THE LU
C     DECOMPOSITION STRUCTURE.  THIS ROUTINE EXECUTES ABOUT FIVE TIMES
C     FASTER THAN MA30A/AD.
C
C WE NOW DESCRIBE THE ARGUMENT LIST FOR MA30B/BD. CONSULT MA30A/AD FOR
C     FURTHER INFORMATION ON THESE PARAMETERS.
C N  IS AN INTEGER VARIABLE SET TO THE ORDER OF THE MATRIX.
C ICN IS AN INTEGER ARRAY OF LENGTH LICN. IT SHOULD BE UNCHANGED
C     SINCE THE LAST CALL TO MA30A/AD. IT IS NOT ALTERED BY MA30B/BD.
C A  IS A REAL/DOUBLE PRECISION ARRAY OF LENGTH LICN THE USER MUST SET
C     ENTRIES IDISP(1) TO IDISP(2) TO CONTAIN THE ENTRIES IN THE
C     DIAGONAL BLOCKS OF THE MATRIX PAQ WHOSE COLUMN NUMBERS ARE HELD
C     IN ICN, USING CORRESPONDING POSITIONS. NOTE THAT SOME ZEROS MAY
C     NEED TO BE HELD EXPLICITLY. ON OUTPUT ENTRIES IDISP(1) TO
C     IDISP(2) OF ARRAY A CONTAIN THE LU DECOMPOSITION OF THE DIAGONAL
C     BLOCKS OF PAQ. ENTRIES A(1) TO A(IDISP(1)-1) ARE NEITHER
C     REQUIRED NOR ALTERED BY MA30B/BD.
C LICN  IS AN INTEGER VARIABLE WHICH MUST BE SET BY THE USER TO THE
C     LENGTH OF ARRAYS A AND ICN. IT IS NOT ALTERED BY MA30B/BD.
C LENR,LENRL ARE INTEGER ARRAYS OF LENGTH N. THEY SHOULD BE
C     UNCHANGED SINCE THE LAST CALL TO MA30A/AD. THEY ARE NOT ALTERED
C     BY MA30B/BD.
C IDISP  IS AN INTEGER ARRAY OF LENGTH 2. IT SHOULD BE UNCHANGED SINCE
C     THE LAST CALL TO MA30A/AD. IT IS NOT ALTERED BY MA30B/BD.
C IP,IQ  ARE INTEGER ARRAYS OF LENGTH N. THEY SHOULD BE UNCHANGED
C     SINCE THE LAST CALL TO MA30A/AD. THEY ARE NOT ALTERED BY
C     MA30B/BD.
C W  IS A REAL/DOUBLE PRECISION ARRAY OF LENGTH N WHICH IS USED AS
C     WORKSPACE BY MA30B/BD.
C IW  IS AN INTEGER ARRAY OF LENGTH N WHICH IS USED AS WORKSPACE BY
C     MA30B/BD.
C IFLAG  IS AN INTEGER VARIABLE. ON OUTPUT FROM MA30B/BD, IFLAG HAS
C     THE VALUE ZERO IF THE FACTORIZATION WAS SUCCESSFUL, HAS THE
C     VALUE I IF PIVOT I WAS VERY SMALL AND HAS THE VALUE -I IF AN
C     UNEXPECTED SINGULARITY WAS DETECTED AT STAGE I OF THE
C     DECOMPOSITION.
C
C SEE BLOCK DATA FOR COMMENTS ON VARIABLES IN COMMON.
C     .. Parameters ..
      DOUBLE PRECISION ZERO,ONE
      PARAMETER (ZERO=0.0D0,ONE=1.0D0)
C     ..
C     .. Scalar Arguments ..
      INTEGER IFLAG,LICN,N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(LICN),W(N)
      INTEGER ICN(LICN),IDISP(2),IP(N),IQ(N),IW(N),LENR(N),LENRL(N)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION AU,ROWMAX
      INTEGER I,IFIN,ILEND,IPIVJ,ISING,ISTART,J,JAY,JAYJAY,JFIN,JJ,
     +        PIVPOS
      LOGICAL STAB
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC DABS,DMAX1
C     ..
C     .. Common blocks ..
      COMMON /MA30ED/LP,ABORT1,ABORT2,ABORT3
      COMMON /MA30GD/EPS,RMIN
      COMMON /MA30ID/TOL,BIG,NDROP,NSRCH,LBIG
      DOUBLE PRECISION BIG,EPS,RMIN,TOL
      INTEGER LP,NDROP,NSRCH
      LOGICAL ABORT1,ABORT2,ABORT3,LBIG
C     ..
C     .. Save statement ..
      SAVE /MA30ED/,/MA30GD/,/MA30ID/
C     ..
C     .. Executable Statements ..
      STAB = EPS .LE. ONE
      RMIN = EPS
      ISING = 0
      IFLAG = 0
      DO 10 I = 1,N
        W(I) = ZERO
   10 CONTINUE
C SET UP POINTERS TO THE BEGINNING OF THE ROWS.
      IW(1) = IDISP(1)
      IF (N.EQ.1) GO TO 25
      DO 20 I = 2,N
        IW(I) = IW(I-1) + LENR(I-1)
   20 CONTINUE
C
C   ****   START  OF MAIN LOOP    ****
C AT STEP I, ROW I OF A IS TRANSFORMED TO ROW I OF L/U BY ADDING
C     APPROPRIATE MULTIPLES OF ROWS 1 TO I-1.
C     .... USING ROW-GAUSS ELIMINATION.
   25 DO 160 I = 1,N
C ISTART IS BEGINNING OF ROW I OF A AND ROW I OF L.
        ISTART = IW(I)
C IFIN IS END OF ROW I OF A AND ROW I OF U.
        IFIN = ISTART + LENR(I) - 1
C ILEND IS END OF ROW I OF L.
        ILEND = ISTART + LENRL(I) - 1
        IF (ISTART.GT.ILEND) GO TO 90
C LOAD ROW I OF A INTO VECTOR W.
        DO 30 JJ = ISTART,IFIN
          J = ICN(JJ)
          W(J) = A(JJ)
   30   CONTINUE
C
C ADD MULTIPLES OF APPROPRIATE ROWS OF  I TO I-1  TO ROW I.
        DO 70 JJ = ISTART,ILEND
          J = ICN(JJ)
C IPIVJ IS POSITION OF PIVOT IN ROW J.
          IPIVJ = IW(J) + LENRL(J)
C FORM MULTIPLIER AU.
          AU = -W(J)/A(IPIVJ)
          IF (LBIG) BIG = DMAX1(DABS(AU),BIG)
          W(J) = AU
C AU * ROW J (U PART) IS ADDED TO ROW I.
          IPIVJ = IPIVJ + 1
          JFIN = IW(J) + LENR(J) - 1
          IF (IPIVJ.GT.JFIN) GO TO 70
C INNERMOST LOOP.
          IF (LBIG) GO TO 50
          DO 40 JAYJAY = IPIVJ,JFIN
            JAY = ICN(JAYJAY)
            W(JAY) = W(JAY) + AU*A(JAYJAY)
   40     CONTINUE
          GO TO 70

   50     DO 60 JAYJAY = IPIVJ,JFIN
            JAY = ICN(JAYJAY)
            W(JAY) = W(JAY) + AU*A(JAYJAY)
            BIG = DMAX1(DABS(W(JAY)),BIG)
   60     CONTINUE
   70   CONTINUE
C
C RELOAD W BACK INTO A (NOW L/U)
        DO 80 JJ = ISTART,IFIN
          J = ICN(JJ)
          A(JJ) = W(J)
          W(J) = ZERO
   80   CONTINUE
C WE NOW PERFORM THE STABILITY CHECKS.
   90   PIVPOS = ILEND + 1
        IF (IQ(I).GT.0) GO TO 140
C MATRIX HAD SINGULARITY AT THIS POINT IN MA30A/AD.
C IS IT THE FIRST SUCH PIVOT IN CURRENT BLOCK ?
        IF (ISING.EQ.0) ISING = I
C DOES CURRENT MATRIX HAVE A SINGULARITY IN THE SAME PLACE ?
        IF (PIVPOS.GT.IFIN) GO TO 100
        IF (A(PIVPOS).NE.ZERO) GO TO 170
C IT DOES .. SO SET ISING IF IT IS NOT THE END OF THE CURRENT BLOCK
C CHECK TO SEE THAT APPROPRIATE PART OF L/U IS ZERO OR NULL.
  100   IF (ISTART.GT.IFIN) GO TO 120
        DO 110 JJ = ISTART,IFIN
          IF (ICN(JJ).LT.ISING) GO TO 110
          IF (A(JJ).NE.ZERO) GO TO 170
  110   CONTINUE
  120   IF (PIVPOS.LE.IFIN) A(PIVPOS) = ONE
        IF (IP(I).GT.0 .AND. I.NE.N) GO TO 160
C END OF CURRENT BLOCK ... RESET ZERO PIVOTS AND ISING.
        DO 130 J = ISING,I
          IF ((LENR(J)-LENRL(J)).EQ.0) GO TO 130
          JJ = IW(J) + LENRL(J)
          A(JJ) = ZERO
  130   CONTINUE
        ISING = 0
        GO TO 160
C MATRIX HAD NON-ZERO PIVOT IN MA30A/AD AT THIS STAGE.
  140   IF (PIVPOS.GT.IFIN) GO TO 170
        IF (A(PIVPOS).EQ.ZERO) GO TO 170
        IF (.NOT.STAB) GO TO 160
        ROWMAX = ZERO
        DO 150 JJ = PIVPOS,IFIN
          ROWMAX = DMAX1(ROWMAX,DABS(A(JJ)))
  150   CONTINUE
        IF (DABS(A(PIVPOS))/ROWMAX.GE.RMIN) GO TO 160
        IFLAG = I
        RMIN = DABS(A(PIVPOS))/ROWMAX
C   ****    END OF MAIN LOOP    ****
  160 CONTINUE
C
      GO TO 180
C   ***   ERROR RETURN   ***
  170 IF (LP.NE.0) WRITE (LP,FMT=99999) I
      IFLAG = -I
C
  180 RETURN

99999 FORMAT (' ERROR RETURN FROM MA30B/BD SINGULARITY DETECTED IN RO',
     +       'W',I8)

      END
      SUBROUTINE MA30CD(N,ICN,A,LICN,LENR,LENRL,LENOFF,IDISP,IP,IQ,X,W,
     +                  MTYPE)
C MA30C/CD USES THE FACTORS PRODUCED BY MA30A/AD OR MA30B/BD TO SOLVE
C     AX=B OR A TRANSPOSE X=B WHEN THE MATRIX P1*A*Q1 (PAQ) IS BLOCK
C     LOWER TRIANGULAR (INCLUDING THE CASE OF ONLY ONE DIAGONAL
C     BLOCK).
C
C WE NOW DESCRIBE THE ARGUMENT LIST FOR MA30C/CD.
C N  IS AN INTEGER VARIABLE SET TO THE ORDER OF THE MATRIX. IT IS NOT
C     ALTERED BY THE SUBROUTINE.
C ICN IS AN INTEGER ARRAY OF LENGTH LICN. ENTRIES IDISP(1) TO
C     IDISP(2) SHOULD BE UNCHANGED SINCE THE LAST CALL TO MA30A/AD. IF
C     THE MATRIX HAS MORE THAN ONE DIAGONAL BLOCK, THEN COLUMN INDICES
C     CORRESPONDING TO NON-ZEROS IN SUB-DIAGONAL BLOCKS OF PAQ MUST
C     APPEAR IN POSITIONS 1 TO IDISP(1)-1. FOR THE SAME ROW THOSE
C     ENTRIES MUST BE CONTIGUOUS, WITH THOSE IN ROW I PRECEDING THOSE
C     IN ROW I+1 (I=1,...,N-1) AND NO WASTED SPACE BETWEEN ROWS.
C     ENTRIES MAY BE IN ANY ORDER WITHIN EACH ROW. IT IS NOT ALTERED
C     BY MA30C/CD.
C A  IS A REAL/DOUBLE PRECISION ARRAY OF LENGTH LICN.  ENTRIES
C     IDISP(1) TO IDISP(2) SHOULD BE UNCHANGED SINCE THE LAST CALL TO
C     MA30A/AD OR MA30B/BD.  IF THE MATRIX HAS MORE THAN ONE DIAGONAL
C     BLOCK, THEN THE VALUES OF THE NON-ZEROS IN SUB-DIAGONAL BLOCKS
C     MUST BE IN POSITIONS 1 TO IDISP(1)-1 IN THE ORDER GIVEN BY ICN.
C     IT IS NOT ALTERED BY MA30C/CD.
C LICN  IS AN INTEGER VARIABLE SET TO THE SIZE OF ARRAYS ICN AND A.
C     IT IS NOT ALTERED BY MA30C/CD.
C LENR,LENRL ARE INTEGER ARRAYS OF LENGTH N WHICH SHOULD BE
C     UNCHANGED SINCE THE LAST CALL TO MA30A/AD. THEY ARE NOT ALTERED
C     BY MA30C/CD.
C LENOFF  IS AN INTEGER ARRAY OF LENGTH N. IF THE MATRIX PAQ (OR
C     P1*A*Q1) HAS MORE THAN ONE DIAGONAL BLOCK, THEN LENOFF(I),
C     I=1,...,N SHOULD BE SET TO THE NUMBER OF NON-ZEROS IN ROW I OF
C     THE MATRIX PAQ WHICH ARE IN SUB-DIAGONAL BLOCKS.  IF THERE IS
C     ONLY ONE DIAGONAL BLOCK THEN LENOFF(1) MAY BE SET TO -1, IN
C     WHICH CASE THE OTHER ENTRIES OF LENOFF ARE NEVER ACCESSED. IT IS
C     NOT ALTERED BY MA30C/CD.
C IDISP  IS AN INTEGER ARRAY OF LENGTH 2 WHICH SHOULD BE UNCHANGED
C     SINCE THE LAST CALL TO MA30A/AD. IT IS NOT ALTERED BY MA30C/CD.
C IP,IQ ARE INTEGER ARRAYS OF LENGTH N WHICH SHOULD BE UNCHANGED
C     SINCE THE LAST CALL TO MA30A/AD. THEY ARE NOT ALTERED BY
C     MA30C/CD.
C X IS A REAL/DOUBLE PRECISION ARRAY OF LENGTH N. IT MUST BE SET BY
C     THE USER TO THE VALUES OF THE RIGHT HAND SIDE VECTOR B FOR THE
C     EQUATIONS BEING SOLVED.  ON EXIT FROM MA30C/CD IT WILL BE EQUAL
C     TO THE SOLUTION X REQUIRED.
C W  IS A REAL/DOUBLE PRECISION ARRAY OF LENGTH N WHICH IS USED AS
C     WORKSPACE BY MA30C/CD.
C MTYPE IS AN INTEGER VARIABLE WHICH MUST BE SET BY THE USER. IF
C     MTYPE=1, THEN THE SOLUTION TO THE SYSTEM AX=B IS RETURNED; ANY
C     OTHER VALUE FOR MTYPE WILL RETURN THE SOLUTION TO THE SYSTEM A
C     TRANSPOSE X=B. IT IS NOT ALTERED BY MA30C/CD.
C
C SEE BLOCK DATA FOR COMMENTS ON VARIABLES IN COMMON.
C     .. Parameters ..
      DOUBLE PRECISION ZERO
      PARAMETER (ZERO=0.0D0)
C     ..
C     .. Scalar Arguments ..
      INTEGER LICN,MTYPE,N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(LICN),W(N),X(N)
      INTEGER ICN(LICN),IDISP(2),IP(N),IQ(N),LENOFF(*),LENR(N),LENRL(N)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION WI,WII
      INTEGER I,IB,IBACK,IBLEND,IBLOCK,IEND,IFIRST,II,III,ILAST,J,J1,J2,
     +        J3,JJ,JPIV,JPIVP1,K,LJ1,LJ2,LT,LTEND,NUMBLK
      LOGICAL NEG,NOBLOC
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC DABS,DMAX1,IABS
C     ..
C     .. Common blocks ..
      COMMON /MA30HD/RESID
      DOUBLE PRECISION RESID
C     ..
C     .. Save statement ..
      SAVE /MA30HD/
C     ..
C     .. Executable Statements ..
C
C THE FINAL VALUE OF RESID IS THE MAXIMUM RESIDUAL FOR AN INCONSISTENT
C     SET OF EQUATIONS.
      RESID = ZERO
C NOBLOC IS .TRUE. IF SUBROUTINE BLOCK HAS BEEN USED PREVIOUSLY AND
C     IS .FALSE. OTHERWISE.  THE VALUE .FALSE. MEANS THAT LENOFF
C     WILL NOT BE SUBSEQUENTLY ACCESSED.
      NOBLOC = LENOFF(1) .LT. 0
      IF (MTYPE.NE.1) GO TO 140
C
C WE NOW SOLVE   A * X = B.
C NEG IS USED TO INDICATE WHEN THE LAST ROW IN A BLOCK HAS BEEN
C     REACHED.  IT IS THEN SET TO TRUE WHEREAFTER BACKSUBSTITUTION IS
C     PERFORMED ON THE BLOCK.
      NEG = .FALSE.
C IP(N) IS NEGATED SO THAT THE LAST ROW OF THE LAST BLOCK CAN BE
C     RECOGNISED.  IT IS RESET TO ITS POSITIVE VALUE ON EXIT.
      IP(N) = -IP(N)
C PREORDER VECTOR ... W(I) = X(IP(I))
      DO 10 II = 1,N
        I = IP(II)
        I = IABS(I)
        W(II) = X(I)
   10 CONTINUE
C LT HOLDS THE POSITION OF THE FIRST NON-ZERO IN THE CURRENT ROW OF THE
C     OFF-DIAGONAL BLOCKS.
      LT = 1
C IFIRST HOLDS THE INDEX OF THE FIRST ROW IN THE CURRENT BLOCK.
      IFIRST = 1
C IBLOCK HOLDS THE POSITION OF THE FIRST NON-ZERO IN THE CURRENT ROW
C     OF THE LU DECOMPOSITION OF THE DIAGONAL BLOCKS.
      IBLOCK = IDISP(1)
C IF I IS NOT THE LAST ROW OF A BLOCK, THEN A PASS THROUGH THIS LOOP
C     ADDS THE INNER PRODUCT OF ROW I OF THE OFF-DIAGONAL BLOCKS AND W
C     TO W AND PERFORMS FORWARD ELIMINATION USING ROW I OF THE LU
C     DECOMPOSITION.   IF I IS THE LAST ROW OF A BLOCK THEN, AFTER
C     PERFORMING THESE AFOREMENTIONED OPERATIONS, BACKSUBSTITUTION IS
C     PERFORMED USING THE ROWS OF THE BLOCK.
      DO 120 I = 1,N
        WI = W(I)
        IF (NOBLOC) GO TO 30
        IF (LENOFF(I).EQ.0) GO TO 30
C OPERATIONS USING LOWER TRIANGULAR BLOCKS.
C LTEND IS THE END OF ROW I IN THE OFF-DIAGONAL BLOCKS.
        LTEND = LT + LENOFF(I) - 1
        DO 20 JJ = LT,LTEND
          J = ICN(JJ)
          WI = WI - A(JJ)*W(J)
   20   CONTINUE
C LT IS SET THE BEGINNING OF THE NEXT OFF-DIAGONAL ROW.
        LT = LTEND + 1
C SET NEG TO .TRUE. IF WE ARE ON THE LAST ROW OF THE BLOCK.
   30   IF (IP(I).LT.0) NEG = .TRUE.
        IF (LENRL(I).EQ.0) GO TO 50
C FORWARD ELIMINATION PHASE.
C IEND IS THE END OF THE L PART OF ROW I IN THE LU DECOMPOSITION.
        IEND = IBLOCK + LENRL(I) - 1
        DO 40 JJ = IBLOCK,IEND
          J = ICN(JJ)
          WI = WI + A(JJ)*W(J)
   40   CONTINUE
C IBLOCK IS ADJUSTED TO POINT TO THE START OF THE NEXT ROW.
   50   IBLOCK = IBLOCK + LENR(I)
        W(I) = WI
        IF (.NOT.NEG) GO TO 120
C BACK SUBSTITUTION PHASE.
C J1 IS POSITION IN A/ICN AFTER END OF BLOCK BEGINNING IN ROW IFIRST
C     AND ENDING IN ROW I.
        J1 = IBLOCK
C ARE THERE ANY SINGULARITIES IN THIS BLOCK?  IF NOT, CONTINUE WITH
C     THE BACKSUBSTITUTION.
        IB = I
        IF (IQ(I).GT.0) GO TO 70
        DO 60 III = IFIRST,I
          IB = I - III + IFIRST
          IF (IQ(IB).GT.0) GO TO 70
          J1 = J1 - LENR(IB)
          RESID = DMAX1(RESID,DABS(W(IB)))
          W(IB) = ZERO
   60   CONTINUE
C ENTIRE BLOCK IS SINGULAR.
        GO TO 110
C EACH PASS THROUGH THIS LOOP PERFORMS THE BACK-SUBSTITUTION
C     OPERATIONS FOR A SINGLE ROW, STARTING AT THE END OF THE BLOCK AND
C     WORKING THROUGH IT IN REVERSE ORDER.
   70   DO 100 III = IFIRST,IB
          II = IB - III + IFIRST
C J2 IS END OF ROW II.
          J2 = J1 - 1
C J1 IS BEGINNING OF ROW II.
          J1 = J1 - LENR(II)
C JPIV IS THE POSITION OF THE PIVOT IN ROW II.
          JPIV = J1 + LENRL(II)
          JPIVP1 = JPIV + 1
C JUMP IF ROW  II OF U HAS NO NON-ZEROS.
          IF (J2.LT.JPIVP1) GO TO 90
          WII = W(II)
          DO 80 JJ = JPIVP1,J2
            J = ICN(JJ)
            WII = WII - A(JJ)*W(J)
   80     CONTINUE
          W(II) = WII
   90     W(II) = W(II)/A(JPIV)
  100   CONTINUE
  110   IFIRST = I + 1
        NEG = .FALSE.
  120 CONTINUE
C
C REORDER SOLUTION VECTOR ... X(I) = W(IQINVERSE(I))
      DO 130 II = 1,N
        I = IQ(II)
        I = IABS(I)
        X(I) = W(II)
  130 CONTINUE
      IP(N) = -IP(N)
      GO TO 320
C
C
C WE NOW SOLVE   ATRANSPOSE * X = B.
C PREORDER VECTOR ... W(I)=X(IQ(I))
  140 DO 150 II = 1,N
        I = IQ(II)
        I = IABS(I)
        W(II) = X(I)
  150 CONTINUE
C LJ1 POINTS TO THE BEGINNING THE CURRENT ROW IN THE OFF-DIAGONAL
C     BLOCKS.
      LJ1 = IDISP(1)
C IBLOCK IS INITIALIZED TO POINT TO THE BEGINNING OF THE BLOCK AFTER
C     THE LAST ONE !
      IBLOCK = IDISP(2) + 1
C ILAST IS THE LAST ROW IN THE CURRENT BLOCK.
      ILAST = N
C IBLEND POINTS TO THE POSITION AFTER THE LAST NON-ZERO IN THE
C     CURRENT BLOCK.
      IBLEND = IBLOCK
C EACH PASS THROUGH THIS LOOP OPERATES WITH ONE DIAGONAL BLOCK AND
C     THE OFF-DIAGONAL PART OF THE MATRIX CORRESPONDING TO THE ROWS
C     OF THIS BLOCK.  THE BLOCKS ARE TAKEN IN REVERSE ORDER AND THE
C     NUMBER OF TIMES THE LOOP IS ENTERED IS MIN(N,NO. BLOCKS+1).
      DO 290 NUMBLK = 1,N
        IF (ILAST.EQ.0) GO TO 300
        IBLOCK = IBLOCK - LENR(ILAST)
C THIS LOOP FINDS THE INDEX OF THE FIRST ROW IN THE CURRENT BLOCK..
C     IT IS FIRST AND IBLOCK IS SET TO THE POSITION OF THE BEGINNING
C     OF THIS FIRST ROW.
        DO 160 K = 1,N
          II = ILAST - K
          IF (II.EQ.0) GO TO 170
          IF (IP(II).LT.0) GO TO 170
          IBLOCK = IBLOCK - LENR(II)
  160   CONTINUE
  170   IFIRST = II + 1
C J1 POINTS TO THE POSITION OF THE BEGINNING OF ROW I (LT PART) OR PIVOT
        J1 = IBLOCK
C FORWARD ELIMINATION.
C EACH PASS THROUGH THIS LOOP PERFORMS THE OPERATIONS FOR ONE ROW OF THE
C     BLOCK.  IF THE CORRESPONDING ENTRY OF W IS ZERO THEN THE
C     OPERATIONS CAN BE AVOIDED.
        DO 210 I = IFIRST,ILAST
          IF (W(I).EQ.ZERO) GO TO 200
C JUMP IF ROW I SINGULAR.
          IF (IQ(I).LT.0) GO TO 220
C J2 FIRST POINTS TO THE PIVOT IN ROW I AND THEN IS MADE TO POINT TO THE
C     FIRST NON-ZERO IN THE U TRANSPOSE PART OF THE ROW.
          J2 = J1 + LENRL(I)
          WI = W(I)/A(J2)
          IF (LENR(I)-LENRL(I).EQ.1) GO TO 190
          J2 = J2 + 1
C J3 POINTS TO THE END OF ROW I.
          J3 = J1 + LENR(I) - 1
          DO 180 JJ = J2,J3
            J = ICN(JJ)
            W(J) = W(J) - A(JJ)*WI
  180     CONTINUE
  190     W(I) = WI
  200     J1 = J1 + LENR(I)
  210   CONTINUE
        GO TO 240
C DEALS WITH REST OF BLOCK WHICH IS SINGULAR.
  220   DO 230 II = I,ILAST
          RESID = DMAX1(RESID,DABS(W(II)))
          W(II) = ZERO
  230   CONTINUE
C BACK SUBSTITUTION.
C THIS LOOP DOES THE BACK SUBSTITUTION ON THE ROWS OF THE BLOCK IN
C     THE REVERSE ORDER DOING IT SIMULTANEOUSLY ON THE L TRANSPOSE PART
C     OF THE DIAGONAL BLOCKS AND THE OFF-DIAGONAL BLOCKS.
  240   J1 = IBLEND
        DO 280 IBACK = IFIRST,ILAST
          I = ILAST - IBACK + IFIRST
C J1 POINTS TO THE BEGINNING OF ROW I.
          J1 = J1 - LENR(I)
          IF (LENRL(I).EQ.0) GO TO 260
C J2 POINTS TO THE END OF THE L TRANSPOSE PART OF ROW I.
          J2 = J1 + LENRL(I) - 1
          DO 250 JJ = J1,J2
            J = ICN(JJ)
            W(J) = W(J) + A(JJ)*W(I)
  250     CONTINUE
  260     IF (NOBLOC) GO TO 280
C OPERATIONS USING LOWER TRIANGULAR BLOCKS.
          IF (LENOFF(I).EQ.0) GO TO 280
C LJ2 POINTS TO THE END OF ROW I OF THE OFF-DIAGONAL BLOCKS.
          LJ2 = LJ1 - 1
C LJ1 POINTS TO THE BEGINNING OF ROW I OF THE OFF-DIAGONAL BLOCKS.
          LJ1 = LJ1 - LENOFF(I)
          DO 270 JJ = LJ1,LJ2
            J = ICN(JJ)
            W(J) = W(J) - A(JJ)*W(I)
  270     CONTINUE
  280   CONTINUE
        IBLEND = J1
        ILAST = IFIRST - 1
  290 CONTINUE
C REORDER SOLUTION VECTOR ... X(I)=W(IPINVERSE(I))
  300 DO 310 II = 1,N
        I = IP(II)
        I = IABS(I)
        X(I) = W(II)
  310 CONTINUE
C
  320 RETURN

      END
      SUBROUTINE MA30DD(A,ICN,IPTR,N,IACTIV,ITOP,REALS)
C THIS SUBROUTINE PERFORMS GARBAGE COLLECTION OPERATIONS ON THE
C     ARRAYS A, ICN AND IRN.
C IACTIV IS THE FIRST POSITION IN ARRAYS A/ICN FROM WHICH THE COMPRESS
C     STARTS.  ON EXIT, IACTIV EQUALS THE POSITION OF THE FIRST ENTRY
C     IN THE COMPRESSED PART OF A/ICN
C
C SEE BLOCK DATA FOR COMMENTS ON VARIABLES IN COMMON.
C
C     .. Scalar Arguments ..
      INTEGER IACTIV,ITOP,N
      LOGICAL REALS
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(ITOP)
      INTEGER ICN(ITOP),IPTR(N)
C     ..
C     .. Local Scalars ..
      INTEGER J,JPOS,K,KL,KN
C     ..
C     .. Common blocks ..
      COMMON /MA30FD/IRNCP,ICNCP,IRANK,MINIRN,MINICN
      INTEGER ICNCP,IRANK,IRNCP,MINICN,MINIRN
C     ..
C     .. Save statement ..
      SAVE /MA30FD/
C     ..
C     .. Executable Statements ..
      IF (REALS) ICNCP = ICNCP + 1
      IF (.NOT.REALS) IRNCP = IRNCP + 1
C SET THE FIRST NON-ZERO ENTRY IN EACH ROW TO THE NEGATIVE OF THE
C     ROW/COL NUMBER AND HOLD THIS ROW/COL INDEX IN THE ROW/COL
C     POINTER.  THIS IS SO THAT THE BEGINNING OF EACH ROW/COL CAN
C     BE RECOGNIZED IN THE SUBSEQUENT SCAN.
      DO 10 J = 1,N
        K = IPTR(J)
        IF (K.LT.IACTIV) GO TO 10
        IPTR(J) = ICN(K)
        ICN(K) = -J
   10 CONTINUE
      KN = ITOP + 1
      KL = ITOP - IACTIV + 1
C GO THROUGH ARRAYS IN REVERSE ORDER COMPRESSING TO THE BACK SO
C     THAT THERE ARE NO ZEROS HELD IN POSITIONS IACTIV TO ITOP IN ICN.
C     RESET FIRST ENTRY OF EACH ROW/COL AND POINTER ARRAY IPTR.
      DO 30 K = 1,KL
        JPOS = ITOP - K + 1
        IF (ICN(JPOS).EQ.0) GO TO 30
        KN = KN - 1
        IF (REALS) A(KN) = A(JPOS)
        IF (ICN(JPOS).GE.0) GO TO 20
C FIRST NON-ZERO OF ROW/COL HAS BEEN LOCATED
        J = -ICN(JPOS)
        ICN(JPOS) = IPTR(J)
        IPTR(J) = KN
   20   ICN(KN) = ICN(JPOS)
   30 CONTINUE
      IACTIV = KN
      RETURN

      END
      BLOCK DATA MA30JD
C ALTHOUGH ALL COMMON BLOCK VARIABLES DO NOT HAVE DEFAULT VALUES,
C     WE COMMENT ON ALL THE COMMON BLOCK VARIABLES HERE.
C
C COMMON BLOCK MA30E/ED HOLDS CONTROL PARAMETERS ....
C     COMMON /MA30ED/ LP, ABORT1, ABORT2, ABORT3
C THE INTEGER LP IS THE UNIT NUMBER TO WHICH THE ERROR MESSAGES ARE
C     SENT. LP HAS A DEFAULT VALUE OF 6.  THIS DEFAULT VALUE CAN BE
C     RESET BY THE USER, IF DESIRED.  A VALUE OF 0 SUPPRESSES ALL
C     MESSAGES.
C THE LOGICAL VARIABLES ABORT1,ABORT2,ABORT3 ARE USED TO CONTROL THE
C     CONDITIONS UNDER WHICH THE SUBROUTINE WILL TERMINATE.
C IF ABORT1 IS .TRUE. THEN THE SUBROUTINE WILL EXIT  IMMEDIATELY ON
C     DETECTING STRUCTURAL SINGULARITY.
C IF ABORT2 IS .TRUE. THEN THE SUBROUTINE WILL EXIT IMMEDIATELY ON
C     DETECTING NUMERICAL SINGULARITY.
C IF ABORT3 IS .TRUE. THEN THE SUBROUTINE WILL EXIT IMMEDIATELY WHEN
C     THE AVAILABLE SPACE IN A/ICN IS FILLED UP BY THE PREVIOUSLY
C     DECOMPOSED, ACTIVE, AND UNDECOMPOSED PARTS OF THE MATRIX.
C THE DEFAULT VALUES FOR ABORT1,ABORT2,ABORT3 ARE SET TO .TRUE.,.TRUE.
C     AND .FALSE. RESPECTIVELY.
C
C THE VARIABLES IN THE COMMON BLOCK MA30F/FD ARE USED TO PROVIDE THE
C     USER WITH INFORMATION ON THE DECOMPOSITION.
C     COMMON /MA30FD/ IRNCP, ICNCP, IRANK, MINIRN, MINICN
C IRNCP AND ICNCP ARE INTEGER VARIABLES USED TO MONITOR THE ADEQUACY
C     OF THE ALLOCATED SPACE IN ARRAYS IRN AND A/ICN RESPECTIVELY, BY
C     TAKING ACCOUNT OF THE NUMBER OF DATA MANAGEMENT COMPRESSES
C     REQUIRED ON THESE ARRAYS. IF IRNCP OR ICNCP IS FAIRLY LARGE (SAY
C     GREATER THAN N/10), IT MAY BE ADVANTAGEOUS TO INCREASE THE SIZE
C     OF THE CORRESPONDING ARRAY(S).  IRNCP AND ICNCP ARE INITIALIZED
C     TO ZERO ON ENTRY TO MA30A/AD AND ARE INCREMENTED EACH TIME THE
C     COMPRESSING ROUTINE MA30D/DD IS ENTERED.
C ICNCP IS THE NUMBER OF COMPRESSES ON A/ICN.
C IRNCP IS THE NUMBER OF COMPRESSES ON IRN.
C IRANK IS AN INTEGER VARIABLE WHICH GIVES AN ESTIMATE (ACTUALLY AN
C     UPPER BOUND) OF THE RANK OF THE MATRIX. ON AN EXIT WITH IFLAG
C     EQUAL TO 0, THIS WILL BE EQUAL TO N.
C MINIRN IS AN INTEGER VARIABLE WHICH, AFTER A SUCCESSFUL CALL TO
C     MA30A/AD, INDICATES THE MINIMUM LENGTH TO WHICH IRN CAN BE
C     REDUCED WHILE STILL PERMITTING A SUCCESSFUL DECOMPOSITION OF THE
C     SAME MATRIX. IF, HOWEVER, THE USER WERE TO DECREASE THE LENGTH
C     OF IRN TO THAT SIZE, THE NUMBER OF COMPRESSES (IRNCP) MAY BE
C     VERY HIGH AND QUITE COSTLY. IF LIRN IS NOT LARGE ENOUGH TO BEGIN
C     THE DECOMPOSITION ON A DIAGONAL BLOCK, MINIRN WILL BE EQUAL TO
C     THE VALUE REQUIRED TO CONTINUE THE DECOMPOSITION AND IFLAG WILL
C     BE SET TO -3 OR -6. A VALUE OF LIRN SLIGHTLY GREATER THAN THIS
C     (SAY ABOUT N/2) WILL USUALLY PROVIDE ENOUGH SPACE TO COMPLETE
C     THE DECOMPOSITION ON THAT BLOCK. IN THE EVENT OF ANY OTHER
C     FAILURE MINIRN GIVES THE MINIMUM SIZE OF IRN REQUIRED FOR A
C     SUCCESSFUL DECOMPOSITION UP TO THAT POINT.
C MINICN IS AN INTEGER VARIABLE WHICH AFTER A SUCCESSFUL CALL TO
C     MA30A/AD, INDICATES THE MINIMUM SIZE OF LICN REQUIRED TO ENABLE
C     A SUCCESSFUL DECOMPOSITION. IN THE EVENT OF FAILURE WITH IFLAG=
C     -5, MINICN WILL, IF ABORT3 IS LEFT SET TO .FALSE., INDICATE THE
C     MINIMUM LENGTH THAT WOULD BE SUFFICIENT TO PREVENT THIS ERROR IN
C     A SUBSEQUENT RUN ON AN IDENTICAL MATRIX. AGAIN THE USER MAY
C     PREFER TO USE A VALUE OF ICN SLIGHTLY GREATER THAN MINICN FOR
C     SUBSEQUENT RUNS TO AVOID TOO MANY CONPRESSES (ICNCP). IN THE
C     EVENT OF FAILURE WITH IFLAG EQUAL TO ANY NEGATIVE VALUE EXCEPT
C     -4, MINICN WILL GIVE THE MINIMUM LENGTH TO WHICH LICN COULD BE
C     REDUCED TO ENABLE A SUCCESSFUL DECOMPOSITION TO THE POINT AT
C     WHICH FAILURE OCCURRED.  NOTICE THAT, ON A SUCCESSFUL ENTRY
C     IDISP(2) GIVES THE AMOUNT OF SPACE IN A/ICN REQUIRED FOR THE
C     DECOMPOSITION WHILE MINICN WILL USUALLY BE SLIGHTLY GREATER
C     BECAUSE OF THE NEED FOR "ELBOW ROOM".  IF THE USER IS VERY
C     UNSURE HOW LARGE TO MAKE LICN, THE VARIABLE MINICN CAN BE USED
C     TO PROVIDE THAT INFORMATION. A PRELIMINARY RUN SHOULD BE
C     PERFORMED WITH ABORT3 LEFT SET TO .FALSE. AND LICN ABOUT 3/2
C     TIMES AS BIG AS THE NUMBER OF NON-ZEROS IN THE ORIGINAL MATRIX.
C     UNLESS THE INITIAL PROBLEM IS VERY SPARSE (WHEN THE RUN WILL BE
C     SUCCESSFUL) OR FILLS IN EXTREMELY BADLY (GIVING AN ERROR RETURN
C     WITH IFLAG EQUAL TO -4), AN ERROR RETURN WITH IFLAG EQUAL TO -5
C     SHOULD RESULT AND MINICN WILL GIVE THE AMOUNT OF SPACE REQUIRED
C     FOR A SUCCESSFUL DECOMPOSITION.
C
C COMMON BLOCK MA30G/GD IS USED BY THE MA30B/BD ENTRY ONLY.
C     COMMON /MA30GD/ EPS, RMIN
C EPS IS A REAL/DOUBLE PRECISION VARIABLE. IT IS USED TO TEST FOR
C     SMALL PIVOTS. ITS DEFAULT VALUE IS 1.0E-4 (1.0D-4 IN D VERSION).
C     IF THE USER SETS EPS TO ANY VALUE GREATER THAN 1.0, THEN NO
C     CHECK IS MADE ON THE SIZE OF THE PIVOTS. ALTHOUGH THE ABSENCE OF
C     SUCH A CHECK WOULD FAIL TO WARN THE USER OF BAD INSTABILITY, ITS
C     ABSENCE WILL ENABLE MA30B/BD TO RUN SLIGHTLY FASTER. AN  A
C     POSTERIORI  CHECK ON THE STABILITY OF THE FACTORIZATION CAN BE
C     OBTAINED FROM MC24A/AD.
C RMIN IS A REAL/DOUBLE PRECISION VARIABLE WHICH GIVES THE USER SOME
C     INFORMATION ABOUT THE STABILITY OF THE DECOMPOSITION.  AT EACH
C     STAGE OF THE LU DECOMPOSITION THE MAGNITUDE OF THE PIVOT APIV
C     IS COMPARED WITH THE LARGEST OFF-DIAGONAL ENTRY CURRENTLY IN ITS
C     ROW (ROW OF U), ROWMAX SAY. IF THE RATIO
C                       MIN (APIV/ROWMAX)
C     WHERE THE MINIMUM IS TAKEN OVER ALL THE ROWS, IS LESS THAN EPS
C     THEN RMIN IS SET TO THIS MINIMUM VALUE AND IFLAG IS RETURNED
C     WITH THE VALUE +I WHERE I IS THE ROW IN WHICH THIS MINIMUM
C     OCCURS.  IF THE USER SETS EPS GREATER THAN ONE, THEN THIS TEST
C     IS NOT PERFORMED. IN THIS CASE, AND WHEN THERE ARE NO SMALL
C     PIVOTS RMIN WILL BE SET EQUAL TO EPS.
C
C COMMON BLOCK MA30H/HD IS USED BY MA30C/CD ONLY.
C     COMMON /MA30HD/ RESID
C RESID IS A REAL/DOUBLE PRECISION VARIABLE. IN THE CASE OF SINGULAR
C     OR RECTANGULAR MATRICES ITS FINAL VALUE WILL BE EQUAL TO THE
C     MAXIMUM RESIDUAL FOR THE UNSATISFIED EQUATIONS; OTHERWISE ITS
C     VALUE WILL BE SET TO ZERO.
C
C COMMON  BLOCK MA30I/ID CONTROLS THE USE OF DROP TOLERANCES, THE
C     MODIFIED PIVOT OPTION AND THE THE CALCULATION OF THE LARGEST
C     ENTRY IN THE FACTORIZATION PROCESS. THIS COMMON BLOCK WAS ADDED
C     TO THE MA30 PACKAGE IN FEBRUARY, 1983.
C     COMMON /MA30ID/ TOL, BIG, NDROP, NSRCH, LBIG
C TOL IS A REAL/DOUBLE PRECISION VARIABLE.  IF IT IS SET TO A POSITIVE
C     VALUE, THEN MA30A/AD WILL DROP FROM THE FACTORS ANY NON-ZERO
C     WHOSE MODULUS IS LESS THAN TOL.  THE FACTORIZATION WILL THEN
C     REQUIRE LESS STORAGE BUT WILL BE INACCURATE.  AFTER A RUN OF
C     MA30A/AD WHERE ENTRIES HAVE BEEN DROPPED, MA30B/BD  SHOULD NOT
C     BE CALLED.  THE DEFAULT VALUE FOR TOL IS 0.0.
C BIG IS A REAL/DOUBLE PRECISION VARIABLE.  IF LBIG HAS BEEN SET TO
C     .TRUE., BIG WILL BE SET TO THE LARGEST ENTRY ENCOUNTERED DURING
C     THE FACTORIZATION.
C NDROP IS AN INTEGER VARIABLE. IF TOL HAS BEEN SET POSITIVE, ON EXIT
C     FROM MA30A/AD, NDROP WILL HOLD THE NUMBER OF ENTRIES DROPPED
C     FROM THE DATA STRUCTURE.
C NSRCH IS AN INTEGER VARIABLE. IF NSRCH IS SET TO A VALUE LESS THAN
C     OR EQUAL TO N, THEN A DIFFERENT PIVOT OPTION WILL BE EMPLOYED BY
C     MA30A/AD.  THIS MAY RESULT IN DIFFERENT FILL-IN AND EXECUTION
C     TIME FOR MA30A/AD. IF NSRCH IS LESS THAN OR EQUAL TO N, THE
C     WORKSPACE ARRAYS LASTC AND NEXTC ARE NOT REFERENCED BY MA30A/AD.
C     THE DEFAULT VALUE FOR NSRCH IS 32768.
C LBIG IS A LOGICAL VARIABLE. IF LBIG IS SET TO .TRUE., THE VALUE OF
C     THE LARGEST ENTRY ENCOUNTERED IN THE FACTORIZATION BY MA30A/AD
C     IS RETURNED IN BIG.  SETTING LBIG TO .TRUE.  WILL MARGINALLY
C     INCREASE THE FACTORIZATION TIME FOR MA30A/AD AND WILL INCREASE
C     THAT FOR MA30B/BD BY ABOUT 20%.  THE DEFAULT VALUE FOR LBIG IS
C     .FALSE.
C
C     .. Common blocks ..
      COMMON /MA30ED/LP,ABORT1,ABORT2,ABORT3
      COMMON /MA30GD/EPS,RMIN
      COMMON /MA30ID/TOL,BIG,NDROP,NSRCH,LBIG
      DOUBLE PRECISION BIG,EPS,RMIN,TOL
      INTEGER LP,NDROP,NSRCH
      LOGICAL ABORT1,ABORT2,ABORT3,LBIG
C     ..
C     .. Save statement ..
      SAVE /MA30ED/,/MA30GD/,/MA30ID/
C     ..
C     .. Data statements ..
      DATA EPS/1.0D-4/,TOL/0.0D0/,BIG/0.0D0/
      DATA LP/6/,NSRCH/32768/
      DATA LBIG/.FALSE./
      DATA ABORT1/.TRUE./,ABORT2/.TRUE./,ABORT3/.FALSE./
C     ..
C     .. Executable Statements ..
      END
* COPYRIGHT (c) 1976 AEA Technology
* Original date 21 Jan 1993
C       Toolpack tool decs employed.
C	Double version of MC13D (name change only)
C 10 August 2001 DOs terminated with CONTINUE
C 13/3/02 Cosmetic changes applied to reduce single/double differences
C
C 12th July 2004 Version 1.0.0. Version numbering added.

      SUBROUTINE MC13DD(N,ICN,LICN,IP,LENR,IOR,IB,NUM,IW)
C     .. Scalar Arguments ..
      INTEGER LICN,N,NUM
C     ..
C     .. Array Arguments ..
      INTEGER IB(N),ICN(LICN),IOR(N),IP(N),IW(N,3),LENR(N)
C     ..
C     .. External Subroutines ..
      EXTERNAL MC13ED
C     ..
C     .. Executable Statements ..
      CALL MC13ED(N,ICN,LICN,IP,LENR,IOR,IB,NUM,IW(1,1),IW(1,2),IW(1,3))
      RETURN

      END
      SUBROUTINE MC13ED(N,ICN,LICN,IP,LENR,ARP,IB,NUM,LOWL,NUMB,PREV)
C
C ARP(I) IS ONE LESS THAN THE NUMBER OF UNSEARCHED EDGES LEAVING
C     NODE I.  AT THE END OF THE ALGORITHM IT IS SET TO A
C     PERMUTATION WHICH PUTS THE MATRIX IN BLOCK LOWER
C     TRIANGULAR FORM.
C IB(I) IS THE POSITION IN THE ORDERING OF THE START OF THE ITH
C     BLOCK.  IB(N+1-I) HOLDS THE NODE NUMBER OF THE ITH NODE
C     ON THE STACK.
C LOWL(I) IS THE SMALLEST STACK POSITION OF ANY NODE TO WHICH A PATH
C     FROM NODE I HAS BEEN FOUND.  IT IS SET TO N+1 WHEN NODE I
C     IS REMOVED FROM THE STACK.
C NUMB(I) IS THE POSITION OF NODE I IN THE STACK IF IT IS ON
C     IT, IS THE PERMUTED ORDER OF NODE I FOR THOSE NODES
C     WHOSE FINAL POSITION HAS BEEN FOUND AND IS OTHERWISE ZERO.
C PREV(I) IS THE NODE AT THE END OF THE PATH WHEN NODE I WAS
C     PLACED ON THE STACK.
C
C
C   ICNT IS THE NUMBER OF NODES WHOSE POSITIONS IN FINAL ORDERING HAVE
C     BEEN FOUND.
C     .. Scalar Arguments ..
      INTEGER LICN,N,NUM
C     ..
C     .. Array Arguments ..
      INTEGER ARP(N),IB(N),ICN(LICN),IP(N),LENR(N),LOWL(N),NUMB(N),
     +        PREV(N)
C     ..
C     .. Local Scalars ..
      INTEGER DUMMY,I,I1,I2,ICNT,II,ISN,IST,IST1,IV,IW,J,K,LCNT,NNM1,STP
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC MIN
C     ..
C     .. Executable Statements ..
      ICNT = 0
C NUM IS THE NUMBER OF BLOCKS THAT HAVE BEEN FOUND.
      NUM = 0
      NNM1 = N + N - 1
C
C INITIALIZATION OF ARRAYS.
      DO 20 J = 1,N
        NUMB(J) = 0
        ARP(J) = LENR(J) - 1
   20 CONTINUE
C
C
      DO 120 ISN = 1,N
C LOOK FOR A STARTING NODE
        IF (NUMB(ISN).NE.0) GO TO 120
        IV = ISN
C IST IS THE NUMBER OF NODES ON THE STACK ... IT IS THE STACK POINTER.
        IST = 1
C PUT NODE IV AT BEGINNING OF STACK.
        LOWL(IV) = 1
        NUMB(IV) = 1
        IB(N) = IV
C
C THE BODY OF THIS LOOP PUTS A NEW NODE ON THE STACK OR BACKTRACKS.
        DO 110 DUMMY = 1,NNM1
          I1 = ARP(IV)
C HAVE ALL EDGES LEAVING NODE IV BEEN SEARCHED.
          IF (I1.LT.0) GO TO 60
          I2 = IP(IV) + LENR(IV) - 1
          I1 = I2 - I1
C
C LOOK AT EDGES LEAVING NODE IV UNTIL ONE ENTERS A NEW NODE OR
C     ALL EDGES ARE EXHAUSTED.
          DO 50 II = I1,I2
            IW = ICN(II)
C HAS NODE IW BEEN ON STACK ALREADY.
            IF (NUMB(IW).EQ.0) GO TO 100
C UPDATE VALUE OF LOWL(IV) IF NECESSARY.
            LOWL(IV) = MIN(LOWL(IV),LOWL(IW))
   50     CONTINUE
C
C THERE ARE NO MORE EDGES LEAVING NODE IV.
          ARP(IV) = -1
C IS NODE IV THE ROOT OF A BLOCK.
   60     IF (LOWL(IV).LT.NUMB(IV)) GO TO 90
C
C ORDER NODES IN A BLOCK.
          NUM = NUM + 1
          IST1 = N + 1 - IST
          LCNT = ICNT + 1
C PEEL BLOCK OFF THE TOP OF THE STACK STARTING AT THE TOP AND
C     WORKING DOWN TO THE ROOT OF THE BLOCK.
          DO 70 STP = IST1,N
            IW = IB(STP)
            LOWL(IW) = N + 1
            ICNT = ICNT + 1
            NUMB(IW) = ICNT
            IF (IW.EQ.IV) GO TO 80
   70     CONTINUE
   80     IST = N - STP
          IB(NUM) = LCNT
C ARE THERE ANY NODES LEFT ON THE STACK.
          IF (IST.NE.0) GO TO 90
C HAVE ALL THE NODES BEEN ORDERED.
          IF (ICNT.LT.N) GO TO 120
          GO TO 130
C
C BACKTRACK TO PREVIOUS NODE ON PATH.
   90     IW = IV
          IV = PREV(IV)
C UPDATE VALUE OF LOWL(IV) IF NECESSARY.
          LOWL(IV) = MIN(LOWL(IV),LOWL(IW))
          GO TO 110
C
C PUT NEW NODE ON THE STACK.
  100     ARP(IV) = I2 - II - 1
          PREV(IW) = IV
          IV = IW
          IST = IST + 1
          LOWL(IV) = IST
          NUMB(IV) = IST
          K = N + 1 - IST
          IB(K) = IV
  110   CONTINUE
C
  120 CONTINUE
C
C
C PUT PERMUTATION IN THE REQUIRED FORM.
  130 DO 140 I = 1,N
        II = NUMB(I)
        ARP(II) = I
  140 CONTINUE
      RETURN

      END
* COPYRIGHT (c) 1975 AEA Technology
*######DATE 4 Oct 1992
C       Toolpack tool decs employed.
C       Array lengths given explicitly eg A(MAXA)
C
      SUBROUTINE MC20AD(NC,MAXA,A,INUM,JPTR,JNUM,JDISP)
C
C     .. Scalar Arguments ..
      INTEGER JDISP,MAXA,NC
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(MAXA)
      INTEGER INUM(MAXA),JNUM(MAXA),JPTR(NC)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION ACE,ACEP
      INTEGER I,ICE,ICEP,J,JA,JB,JCE,JCEP,K,KR,LOC,NULL
C     ..
C     .. Executable Statements ..
      NULL = -JDISP
C**      CLEAR JPTR
      DO 10 J = 1,NC
        JPTR(J) = 0
   10 CONTINUE
C**      COUNT THE NUMBER OF ELEMENTS IN EACH COLUMN.
      DO 20 K = 1,MAXA
        J = JNUM(K) + JDISP
        JPTR(J) = JPTR(J) + 1
   20 CONTINUE
C**      SET THE JPTR ARRAY
      K = 1
      DO 30 J = 1,NC
        KR = K + JPTR(J)
        JPTR(J) = K
        K = KR
   30 CONTINUE
C
C**      REORDER THE ELEMENTS INTO COLUMN ORDER.  THE ALGORITHM IS AN
C        IN-PLACE SORT AND IS OF ORDER MAXA.
      DO 50 I = 1,MAXA
C        ESTABLISH THE CURRENT ENTRY.
        JCE = JNUM(I) + JDISP
        IF (JCE.EQ.0) GO TO 50
        ACE = A(I)
        ICE = INUM(I)
C        CLEAR THE LOCATION VACATED.
        JNUM(I) = NULL
C        CHAIN FROM CURRENT ENTRY TO STORE ITEMS.
        DO 40 J = 1,MAXA
C        CURRENT ENTRY NOT IN CORRECT POSITION.  DETERMINE CORRECT
C        POSITION TO STORE ENTRY.
          LOC = JPTR(JCE)
          JPTR(JCE) = JPTR(JCE) + 1
C        SAVE CONTENTS OF THAT LOCATION.
          ACEP = A(LOC)
          ICEP = INUM(LOC)
          JCEP = JNUM(LOC)
C        STORE CURRENT ENTRY.
          A(LOC) = ACE
          INUM(LOC) = ICE
          JNUM(LOC) = NULL
C        CHECK IF NEXT CURRENT ENTRY NEEDS TO BE PROCESSED.
          IF (JCEP.EQ.NULL) GO TO 50
C        IT DOES.  COPY INTO CURRENT ENTRY.
          ACE = ACEP
          ICE = ICEP
          JCE = JCEP + JDISP
   40   CONTINUE
C
   50 CONTINUE
C
C**      RESET JPTR VECTOR.
      JA = 1
      DO 60 J = 1,NC
        JB = JPTR(J)
        JPTR(J) = JA
        JA = JB
   60 CONTINUE
      RETURN

      END
      SUBROUTINE MC20BD(NC,MAXA,A,INUM,JPTR)
C     . .
C     .. Scalar Arguments ..
      INTEGER MAXA,NC
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(MAXA)
      INTEGER INUM(MAXA),JPTR(NC)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION ACE
      INTEGER ICE,IK,J,JJ,K,KDUMMY,KLO,KMAX,KOR
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC IABS
C     ..
C     .. Executable Statements ..
      KMAX = MAXA
      DO 50 JJ = 1,NC
        J = NC + 1 - JJ
        KLO = JPTR(J) + 1
        IF (KLO.GT.KMAX) GO TO 40
        KOR = KMAX
        DO 30 KDUMMY = KLO,KMAX
C ITEMS KOR, KOR+1, .... ,KMAX ARE IN ORDER
          ACE = A(KOR-1)
          ICE = INUM(KOR-1)
          DO 10 K = KOR,KMAX
            IK = INUM(K)
            IF (IABS(ICE).LE.IABS(IK)) GO TO 20
            INUM(K-1) = IK
            A(K-1) = A(K)
   10     CONTINUE
          K = KMAX + 1
   20     INUM(K-1) = ICE
          A(K-1) = ACE
          KOR = KOR - 1
   30   CONTINUE
C        NEXT COLUMN
   40   KMAX = KLO - 2
   50 CONTINUE
      RETURN

      END
* COPYRIGHT (c) 1977 AEA Technology
* Original date 8 Oct 1992
C######8/10/92 Toolpack tool decs employed.
C######8/10/92 D version created by name change only.
C 13/3/02 Cosmetic changes applied to reduce single/double differences
C
C 12th July 2004 Version 1.0.0. Version numbering added.

      SUBROUTINE MC21AD(N,ICN,LICN,IP,LENR,IPERM,NUMNZ,IW)
C     .. Scalar Arguments ..
      INTEGER LICN,N,NUMNZ
C     ..
C     .. Array Arguments ..
      INTEGER ICN(LICN),IP(N),IPERM(N),IW(N,4),LENR(N)
C     ..
C     .. External Subroutines ..
      EXTERNAL MC21BD
C     ..
C     .. Executable Statements ..
      CALL MC21BD(N,ICN,LICN,IP,LENR,IPERM,NUMNZ,IW(1,1),IW(1,2),
     +            IW(1,3),IW(1,4))
      RETURN
C
      END
      SUBROUTINE MC21BD(N,ICN,LICN,IP,LENR,IPERM,NUMNZ,PR,ARP,CV,OUT)
C   PR(I) IS THE PREVIOUS ROW TO I IN THE DEPTH FIRST SEARCH.
C IT IS USED AS A WORK ARRAY IN THE SORTING ALGORITHM.
C   ELEMENTS (IPERM(I),I) I=1, ... N  ARE NON-ZERO AT THE END OF THE
C ALGORITHM UNLESS N ASSIGNMENTS HAVE NOT BEEN MADE.  IN WHICH CASE
C (IPERM(I),I) WILL BE ZERO FOR N-NUMNZ ENTRIES.
C   CV(I) IS THE MOST RECENT ROW EXTENSION AT WHICH COLUMN I
C WAS VISITED.
C   ARP(I) IS ONE LESS THAN THE NUMBER OF NON-ZEROS IN ROW I
C WHICH HAVE NOT BEEN SCANNED WHEN LOOKING FOR A CHEAP ASSIGNMENT.
C   OUT(I) IS ONE LESS THAN THE NUMBER OF NON-ZEROS IN ROW I
C WHICH HAVE NOT BEEN SCANNED DURING ONE PASS THROUGH THE MAIN LOOP.
C
C   INITIALIZATION OF ARRAYS.
C     .. Scalar Arguments ..
      INTEGER LICN,N,NUMNZ
C     ..
C     .. Array Arguments ..
      INTEGER ARP(N),CV(N),ICN(LICN),IP(N),IPERM(N),LENR(N),OUT(N),PR(N)
C     ..
C     .. Local Scalars ..
      INTEGER I,II,IN1,IN2,IOUTK,J,J1,JORD,K,KK
C     ..
C     .. Executable Statements ..
      DO 10 I = 1,N
        ARP(I) = LENR(I) - 1
        CV(I) = 0
        IPERM(I) = 0
   10 CONTINUE
      NUMNZ = 0
C
C
C   MAIN LOOP.
C   EACH PASS ROUND THIS LOOP EITHER RESULTS IN A NEW ASSIGNMENT
C OR GIVES A ROW WITH NO ASSIGNMENT.
      DO 100 JORD = 1,N
        J = JORD
        PR(J) = -1
        DO 70 K = 1,JORD
C LOOK FOR A CHEAP ASSIGNMENT
          IN1 = ARP(J)
          IF (IN1.LT.0) GO TO 30
          IN2 = IP(J) + LENR(J) - 1
          IN1 = IN2 - IN1
          DO 20 II = IN1,IN2
            I = ICN(II)
            IF (IPERM(I).EQ.0) GO TO 80
   20     CONTINUE
C   NO CHEAP ASSIGNMENT IN ROW.
          ARP(J) = -1
C   BEGIN LOOKING FOR ASSIGNMENT CHAIN STARTING WITH ROW J.
   30     CONTINUE
          OUT(J) = LENR(J) - 1
C INNER LOOP.  EXTENDS CHAIN BY ONE OR BACKTRACKS.
          DO 60 KK = 1,JORD
            IN1 = OUT(J)
            IF (IN1.LT.0) GO TO 50
            IN2 = IP(J) + LENR(J) - 1
            IN1 = IN2 - IN1
C FORWARD SCAN.
            DO 40 II = IN1,IN2
              I = ICN(II)
              IF (CV(I).EQ.JORD) GO TO 40
C   COLUMN I HAS NOT YET BEEN ACCESSED DURING THIS PASS.
              J1 = J
              J = IPERM(I)
              CV(I) = JORD
              PR(J) = J1
              OUT(J1) = IN2 - II - 1
              GO TO 70
C
   40       CONTINUE
C
C   BACKTRACKING STEP.
   50       CONTINUE
            J = PR(J)
            IF (J.EQ.-1) GO TO 100
   60     CONTINUE
C
   70   CONTINUE
C
C   NEW ASSIGNMENT IS MADE.
   80   CONTINUE
        IPERM(I) = J
        ARP(J) = IN2 - II - 1
        NUMNZ = NUMNZ + 1
        DO 90 K = 1,JORD
          J = PR(J)
          IF (J.EQ.-1) GO TO 100
          II = IP(J) + LENR(J) - OUT(J) - 2
          I = ICN(II)
          IPERM(I) = J
   90   CONTINUE
C
  100 CONTINUE
C
C   IF MATRIX IS STRUCTURALLY SINGULAR, WE NOW COMPLETE THE
C PERMUTATION IPERM.
      IF (NUMNZ.EQ.N) RETURN
      DO 110 I = 1,N
        ARP(I) = 0
  110 CONTINUE
      K = 0
      DO 130 I = 1,N
        IF (IPERM(I).NE.0) GO TO 120
        K = K + 1
        OUT(K) = I
        GO TO 130
C
  120   CONTINUE
        J = IPERM(I)
        ARP(J) = I
  130 CONTINUE
      K = 0
      DO 140 I = 1,N
        IF (ARP(I).NE.0) GO TO 140
        K = K + 1
        IOUTK = OUT(K)
        IPERM(IOUTK) = I
  140 CONTINUE
      RETURN
C
      END
* COPYRIGHT (c) 1976 AEA Technology
* Original date 21 Jan 1993
C 8 August 2000: CONTINUEs given to DOs.
C 20/2/02 Cosmetic changes applied to reduce single/double differences

C
C 12th July 2004 Version 1.0.0. Version numbering added.

      SUBROUTINE MC22AD(N,ICN,A,NZ,LENROW,IP,IQ,IW,IW1)
C     .. Scalar Arguments ..
      INTEGER N,NZ
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(NZ)
      INTEGER ICN(NZ),IP(N),IQ(N),IW(N,2),IW1(NZ),LENROW(N)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION AVAL
      INTEGER I,ICHAIN,IOLD,IPOS,J,J2,JJ,JNUM,JVAL,LENGTH,NEWPOS
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC IABS
C     ..
C     .. Executable Statements ..
      IF (NZ.LE.0) GO TO 1000
      IF (N.LE.0) GO TO 1000
C SET START OF ROW I IN IW(I,1) AND LENROW(I) IN IW(I,2)
      IW(1,1) = 1
      IW(1,2) = LENROW(1)
      DO 10 I = 2,N
        IW(I,1) = IW(I-1,1) + LENROW(I-1)
        IW(I,2) = LENROW(I)
   10 CONTINUE
C PERMUTE LENROW ACCORDING TO IP.  SET OFF-SETS FOR NEW POSITION
C     OF ROW IOLD IN IW(IOLD,1) AND PUT OLD ROW INDICES IN IW1 IN
C     POSITIONS CORRESPONDING TO THE NEW POSITION OF THIS ROW IN A/ICN.
      JJ = 1
      DO 20 I = 1,N
        IOLD = IP(I)
        IOLD = IABS(IOLD)
        LENGTH = IW(IOLD,2)
        LENROW(I) = LENGTH
        IF (LENGTH.EQ.0) GO TO 20
        IW(IOLD,1) = IW(IOLD,1) - JJ
        J2 = JJ + LENGTH - 1
        DO 15 J = JJ,J2
          IW1(J) = IOLD
   15   CONTINUE
        JJ = J2 + 1
   20 CONTINUE
C SET INVERSE PERMUTATION TO IQ IN IW(.,2).
      DO 30 I = 1,N
        IOLD = IQ(I)
        IOLD = IABS(IOLD)
        IW(IOLD,2) = I
   30 CONTINUE
C PERMUTE A AND ICN IN PLACE, CHANGING TO NEW COLUMN NUMBERS.
C
C ***   MAIN LOOP   ***
C EACH PASS THROUGH THIS LOOP PLACES A CLOSED CHAIN OF COLUMN INDICES
C     IN THEIR NEW (AND FINAL) POSITIONS ... THIS IS RECORDED BY
C     SETTING THE IW1 ENTRY TO ZERO SO THAT ANY WHICH ARE SUBSEQUENTLY
C     ENCOUNTERED DURING THIS MAJOR SCAN CAN BE BYPASSED.
      DO 200 I = 1,NZ
        IOLD = IW1(I)
        IF (IOLD.EQ.0) GO TO 200
        IPOS = I
        JVAL = ICN(I)
C IF ROW IOLD IS IN SAME POSITIONS AFTER PERMUTATION GO TO 150.
        IF (IW(IOLD,1).EQ.0) GO TO 150
        AVAL = A(I)
C **  CHAIN LOOP  **
C EACH PASS THROUGH THIS LOOP PLACES ONE (PERMUTED) COLUMN INDEX
C     IN ITS FINAL POSITION  .. VIZ. IPOS.
        DO 100 ICHAIN = 1,NZ
C NEWPOS IS THE ORIGINAL POSITION IN A/ICN OF THE ELEMENT TO BE PLACED
C IN POSITION IPOS.  IT IS ALSO THE POSITION OF THE NEXT ELEMENT IN
C     THE CHAIN.
          NEWPOS = IPOS + IW(IOLD,1)
C IS CHAIN COMPLETE ?
          IF (NEWPOS.EQ.I) GO TO 130
          A(IPOS) = A(NEWPOS)
          JNUM = ICN(NEWPOS)
          ICN(IPOS) = IW(JNUM,2)
          IPOS = NEWPOS
          IOLD = IW1(IPOS)
          IW1(IPOS) = 0
C **  END OF CHAIN LOOP  **
  100   CONTINUE
  130   A(IPOS) = AVAL
  150   ICN(IPOS) = IW(JVAL,2)
C ***   END OF MAIN LOOP   ***
  200 CONTINUE
C
 1000 RETURN

      END
* COPYRIGHT (c) 1993 AEA Technology
*######DATE 21 Jan 1993
C       Toolpack tool decs employed.
C       SAVE statements added.
C       MC23CD reference removed.
C 12/12/94 Calls of MC13D and MC21A changed to MC13DD and MC21AD
C
C  EAT 21/6/93 EXTERNAL statement put in for block data on VAXs.
C
C
      SUBROUTINE MC23AD(N,ICN,A,LICN,LENR,IDISP,IP,IQ,LENOFF,IW,IW1)
C INPUT ... N,ICN .. A,ICN,LENR ....
C
C SET UP POINTERS IW(.,1) TO THE BEGINNING OF THE ROWS AND SET LENOFF
C     EQUAL TO LENR.
C     .. Scalar Arguments ..
      INTEGER LICN,N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(LICN)
      INTEGER ICN(LICN),IDISP(2),IP(N),IQ(N),IW(N,5),IW1(N,2),LENOFF(N),
     +        LENR(N)
C     ..
C     .. Local Scalars ..
      INTEGER I,I1,I2,IBEG,IBLOCK,IEND,II,ILEND,INEW,IOLD,IROWB,IROWE,J,
     +        JJ,JNEW,JNPOS,JOLD,K,LENI,NZ
C     ..
C     .. External Subroutines ..
      EXTERNAL MC13DD,MC21AD
C     ..
C     .. Data block external statement
      EXTERNAL MC23CD
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC MAX0,MIN0
C     ..
C     .. Common blocks ..
      COMMON /MC23BD/LP,NUMNZ,NUM,LARGE,ABORT
      INTEGER LARGE,LP,NUM,NUMNZ
      LOGICAL ABORT
C     ..
C     .. Save statement ..
      SAVE /MC23BD/
C     ..
C     .. Executable Statements ..
      IW1(1,1) = 1
      LENOFF(1) = LENR(1)
      IF (N.EQ.1) GO TO 20
      DO 10 I = 2,N
        LENOFF(I) = LENR(I)
   10 IW1(I,1) = IW1(I-1,1) + LENR(I-1)
C IDISP(1) POINTS TO THE FIRST POSITION IN A/ICN AFTER THE
C     OFF-DIAGONAL BLOCKS AND UNTREATED ROWS.
   20 IDISP(1) = IW1(N,1) + LENR(N)
C
C FIND ROW PERMUTATION IP TO MAKE DIAGONAL ZERO-FREE.
      CALL MC21AD(N,ICN,LICN,IW1,LENR,IP,NUMNZ,IW)
C
C POSSIBLE ERROR RETURN FOR STRUCTURALLY SINGULAR MATRICES.
      IF (NUMNZ.NE.N .AND. ABORT) GO TO 170
C
C IW1(.,2) AND LENR ARE PERMUTATIONS OF IW1(.,1) AND LENR/LENOFF
C     SUITABLE FOR ENTRY
C     TO MC13DD SINCE MATRIX WITH THESE ROW POINTER AND LENGTH ARRAYS
C     HAS MAXIMUM NUMBER OF NON-ZEROS ON THE DIAGONAL.
      DO 30 II = 1,N
        I = IP(II)
        IW1(II,2) = IW1(I,1)
   30 LENR(II) = LENOFF(I)
C
C FIND SYMMETRIC PERMUTATION IQ TO BLOCK LOWER TRIANGULAR FORM.
      CALL MC13DD(N,ICN,LICN,IW1(1,2),LENR,IQ,IW(1,4),NUM,IW)
C
      IF (NUM.NE.1) GO TO 60
C
C ACTION TAKEN IF MATRIX IS IRREDUCIBLE.
C WHOLE MATRIX IS JUST MOVED TO THE END OF THE STORAGE.
      DO 40 I = 1,N
        LENR(I) = LENOFF(I)
        IP(I) = I
   40 IQ(I) = I
      LENOFF(1) = -1
C IDISP(1) IS THE FIRST POSITION AFTER THE LAST ELEMENT IN THE
C     OFF-DIAGONAL BLOCKS AND UNTREATED ROWS.
      NZ = IDISP(1) - 1
      IDISP(1) = 1
C IDISP(2) IS THE POSITION IN A/ICN OF THE FIRST ELEMENT IN THE
C     DIAGONAL BLOCKS.
      IDISP(2) = LICN - NZ + 1
      LARGE = N
      IF (NZ.EQ.LICN) GO TO 230
      DO 50 K = 1,NZ
        J = NZ - K + 1
        JJ = LICN - K + 1
        A(JJ) = A(J)
   50 ICN(JJ) = ICN(J)
C 230 = RETURN
      GO TO 230
C
C DATA STRUCTURE REORDERED.
C
C FORM COMPOSITE ROW PERMUTATION ... IP(I) = IP(IQ(I)).
   60 DO 70 II = 1,N
        I = IQ(II)
   70 IW(II,1) = IP(I)
      DO 80 I = 1,N
   80 IP(I) = IW(I,1)
C
C RUN THROUGH BLOCKS IN REVERSE ORDER SEPARATING DIAGONAL BLOCKS
C     WHICH ARE MOVED TO THE END OF THE STORAGE.  ELEMENTS IN
C     OFF-DIAGONAL BLOCKS ARE LEFT IN PLACE UNLESS A COMPRESS IS
C     NECESSARY.
C
C IBEG INDICATES THE LOWEST VALUE OF J FOR WHICH ICN(J) HAS BEEN
C     SET TO ZERO WHEN ELEMENT IN POSITION J WAS MOVED TO THE
C     DIAGONAL BLOCK PART OF STORAGE.
      IBEG = LICN + 1
C IEND IS THE POSITION OF THE FIRST ELEMENT OF THOSE TREATED ROWS
C     WHICH ARE IN DIAGONAL BLOCKS.
      IEND = LICN + 1
C LARGE IS THE DIMENSION OF THE LARGEST BLOCK ENCOUNTERED SO FAR.
      LARGE = 0
C
C NUM IS THE NUMBER OF DIAGONAL BLOCKS.
      DO 150 K = 1,NUM
        IBLOCK = NUM - K + 1
C I1 IS FIRST ROW (IN PERMUTED FORM) OF BLOCK IBLOCK.
C I2 IS LAST ROW (IN PERMUTED FORM) OF BLOCK IBLOCK.
        I1 = IW(IBLOCK,4)
        I2 = N
        IF (K.NE.1) I2 = IW(IBLOCK+1,4) - 1
        LARGE = MAX0(LARGE,I2-I1+1)
C GO THROUGH THE ROWS OF BLOCK IBLOCK IN THE REVERSE ORDER.
        DO 140 II = I1,I2
          INEW = I2 - II + I1
C WE NOW DEAL WITH ROW INEW IN PERMUTED FORM (ROW IOLD IN ORIGINAL
C     MATRIX).
          IOLD = IP(INEW)
C IF THERE IS SPACE TO MOVE UP DIAGONAL BLOCK PORTION OF ROW GO TO 110
          IF (IEND-IDISP(1).GE.LENOFF(IOLD)) GO TO 110
C
C IN-LINE COMPRESS.
C MOVES SEPARATED OFF-DIAGONAL ELEMENTS AND UNTREATED ROWS TO
C     FRONT OF STORAGE.
          JNPOS = IBEG
          ILEND = IDISP(1) - 1
          IF (ILEND.LT.IBEG) GO TO 190
          DO 90 J = IBEG,ILEND
            IF (ICN(J).EQ.0) GO TO 90
            ICN(JNPOS) = ICN(J)
            A(JNPOS) = A(J)
            JNPOS = JNPOS + 1
   90     CONTINUE
          IDISP(1) = JNPOS
          IF (IEND-JNPOS.LT.LENOFF(IOLD)) GO TO 190
          IBEG = LICN + 1
C RESET POINTERS TO THE BEGINNING OF THE ROWS.
          DO 100 I = 2,N
  100     IW1(I,1) = IW1(I-1,1) + LENOFF(I-1)
C
C ROW IOLD IS NOW SPLIT INTO DIAG. AND OFF-DIAG. PARTS.
  110     IROWB = IW1(IOLD,1)
          LENI = 0
          IROWE = IROWB + LENOFF(IOLD) - 1
C BACKWARD SCAN OF WHOLE OF ROW IOLD (IN ORIGINAL MATRIX).
          IF (IROWE.LT.IROWB) GO TO 130
          DO 120 JJ = IROWB,IROWE
            J = IROWE - JJ + IROWB
            JOLD = ICN(J)
C IW(.,2) HOLDS THE INVERSE PERMUTATION TO IQ.
C     ..... IT WAS SET TO THIS IN MC13DD.
            JNEW = IW(JOLD,2)
C IF (JNEW.LT.I1) THEN ....
C ELEMENT IS IN OFF-DIAGONAL BLOCK AND SO IS LEFT IN SITU.
            IF (JNEW.LT.I1) GO TO 120
C ELEMENT IS IN DIAGONAL BLOCK AND IS MOVED TO THE END OF THE STORAGE.
            IEND = IEND - 1
            A(IEND) = A(J)
            ICN(IEND) = JNEW
            IBEG = MIN0(IBEG,J)
            ICN(J) = 0
            LENI = LENI + 1
  120     CONTINUE
C
          LENOFF(IOLD) = LENOFF(IOLD) - LENI
  130     LENR(INEW) = LENI
  140   CONTINUE
C
        IP(I2) = -IP(I2)
  150 CONTINUE
C RESETS IP(N) TO POSITIVE VALUE.
      IP(N) = -IP(N)
C IDISP(2) IS POSITION OF FIRST ELEMENT IN DIAGONAL BLOCKS.
      IDISP(2) = IEND
C
C THIS COMPRESS IS USED TO MOVE ALL OFF-DIAGONAL ELEMENTS TO THE
C     FRONT OF THE STORAGE.
      IF (IBEG.GT.LICN) GO TO 230
      JNPOS = IBEG
      ILEND = IDISP(1) - 1
      DO 160 J = IBEG,ILEND
        IF (ICN(J).EQ.0) GO TO 160
        ICN(JNPOS) = ICN(J)
        A(JNPOS) = A(J)
        JNPOS = JNPOS + 1
  160 CONTINUE
C IDISP(1) IS FIRST POSITION AFTER LAST ELEMENT OF OFF-DIAGONAL BLOCKS.
      IDISP(1) = JNPOS
      GO TO 230
C
C
C ERROR RETURN
  170 IF (LP.NE.0) WRITE (LP,FMT=180) NUMNZ

  180 FORMAT (/,' ERROR RETURN FROM MC23A  BECAUSE',/,10X,
     +       ' MATRIX IS STRUCTURALLY SINGULAR, RANK = ',I6)

      IDISP(1) = -1
      GO TO 230

  190 IF (LP.NE.0) WRITE (LP,FMT=200) N

  200 FORMAT (/,' ERROR RETURN FROM MC23A  BECAUSE',/,10X,
     +       ' LICN NOT BIG ENOUGH INCREASE BY ',I6)

      IDISP(1) = -2
C
  230 RETURN

      END
      BLOCK DATA MC23CD
C     .. Common blocks ..
      COMMON /MC23BD/LP,NUMNZ,NUM,LARGE,ABORT
      INTEGER LARGE,LP,NUM,NUMNZ
      LOGICAL ABORT
C     ..
C     .. Save statement ..
      SAVE /MC23BD/
C     ..
C     .. Data statements ..
      DATA LP/6/,ABORT/.FALSE./
C     ..
C     .. Executable Statements ..
      END
* COPYRIGHT (c) 1977 AEA Technology
*######DATE 22 Feb 1993
C       Toolpack tool decs employed.
C       ZERO made PARAMETER.
C
      SUBROUTINE MC24AD(N,ICN,A,LICN,LENR,LENRL,W)
C     .. Parameters ..
      DOUBLE PRECISION ZERO
      PARAMETER (ZERO=0.0D0)
C     ..
C     .. Scalar Arguments ..
      INTEGER LICN,N
C     ..
C     .. Array Arguments ..
      DOUBLE PRECISION A(LICN),W(N)
      INTEGER ICN(LICN),LENR(N),LENRL(N)
C     ..
C     .. Local Scalars ..
      DOUBLE PRECISION AMAXL,AMAXU,WROWL
      INTEGER I,J,J0,J1,J2,JJ
C     ..
C     .. Intrinsic Functions ..
      INTRINSIC DABS,DMAX1
C     ..
C     .. Executable Statements ..
      AMAXL = ZERO
      DO 10 I = 1,N
   10 W(I) = ZERO
      J0 = 1
      DO 100 I = 1,N
        IF (LENR(I).EQ.0) GO TO 100
        J2 = J0 + LENR(I) - 1
        IF (LENRL(I).EQ.0) GO TO 50
C CALCULATION OF 1-NORM OF L.
        J1 = J0 + LENRL(I) - 1
        WROWL = ZERO
        DO 30 JJ = J0,J1
   30   WROWL = WROWL + DABS(A(JJ))
C AMAXL IS THE MAXIMUM NORM OF COLUMNS OF L SO FAR FOUND.
        AMAXL = DMAX1(AMAXL,WROWL)
        J0 = J1 + 1
C CALCULATION OF NORMS OF COLUMNS OF U (MAX-NORMS).
   50   J0 = J0 + 1
        IF (J0.GT.J2) GO TO 90
        DO 80 JJ = J0,J2
          J = ICN(JJ)
   80   W(J) = DMAX1(DABS(A(JJ)),W(J))
   90   J0 = J2 + 1
  100 CONTINUE
C AMAXU IS SET TO MAXIMUM MAX-NORM OF COLUMNS OF U.
      AMAXU = ZERO
      DO 200 I = 1,N
  200 AMAXU = DMAX1(AMAXU,W(I))
C GROFAC IS MAX U MAX-NORM TIMES MAX L 1-NORM.
      W(1) = AMAXL*AMAXU
      RETURN

      END
